# Паттерны в React, познакомимся с ними поближе

В мире React термин "паттерн" означает какой-то проверенный подход к решению задачи, а не шаблон проектирования из классической книги. За годы разработки вокруг React сформировались свои распространённые паттерны – способы организовать компоненты и логику так, чтобы код получался понятным, поддерживаемым и переиспользуемым.

В этой статье я расскажу вам о самых популярных паттернах, приведу примеры кода, мы рассмотрим, когда каждый из них может пригодиться, а также отметим их плюсы и минусы. Поговорим о классических приёмах вроде контейнеров и HOC, эволюции к хукам, также обязательно рассмотрим новые паттерны появившиеся в последних версиях React.

## 1. Container & Presentational Components

Ещё в мою бытность работы на Vue у моего первого работодателя мы с подачи нашего тимлида решили ввести этот паттерн. Глобально у нас были так называемые "умные" компоненты и "тупые" компоненты (или как я тактично называли их на демо – визуальные). Как вы наверняка догадались, роль Container у нас исполняли "умные" компоненты, а роль Presentational "тупые" компоненты. В чём собственно суть этого паттерна. Слышали выражение "разделяй и властвуй"? Паттерн Container & Presentational Components (контейнерные и презентационные компоненты) ровно об этом: он **разделяет** логику (данные и взаимодействие с ними) и отображение (UI) на разные компоненты.

Presentational Components отвечают **только** за то, *как* что-то выглядит. Они получают данные через `props` и отображают их, больше ничего. Это, как правило, чистые функциональные компоненты, часто без собственного состояния (ну разве что мелкий UI-стейт типа "раскрыт ли dropdown"). Им всё равно, каким образом взять список пользователей – они просто ожидают условный `props.users` и отображают его в соответствии с дизайном.

Container Components, напротив, знают *что* показать и *откуда* это взять, но не занимаются тем, *как* это отображается. Они содержат в себе всю логику: могут загрузить данные, подписаться на store или контекст, хранить состояние, а рендерят в презентационных компоненты, передавая им готовые данные. Контейнер может вообще не иметь собственного HTML, кроме того, что приходит от дочернего презентационного компонента. Его задача – это взаимодействие с данными.

Зачем же нужен такой подход? Во-первых, лучшая разделённость ответственности (UI отдельно, данные отдельно) упрощает понимание и поддержку приложения. Во-вторых, улучшается переиспользование: один визуальный компонент можно использовать с разными источниками данных через разные контейнеры. Дизайнеры могут менять внешний вид компонента в одном месте, не затрагивая бизнес-логику. И тестировать тоже проще: можно отдельно протестировать логику контейнера (без верстки) и отдельно визуальный компонент (с моком данных).

```jsx
// Пример: презентационный компонент списка пользователей
function UserList({ users }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Контейнерный компонент, загружающий пользователей
function UserListContainer() {
  const [users, setUsers] = useState([]);
  
  useEffect(() => {
    fetch('/api/users')
      .then(res => res.json())
      .then(data => setUsers(data));
  }, []);
  
  return <UserList users={users} />;
}
```

В этом примере `UserList` не содержит никакого стейта, не подписан на store или контекст, лишь отображает список. Ему всё равно, как и где получают пользователей – он просто принимает проп `users` и выводит его. Контейнер `UserListContainer` же занимается работой с данными: делает `fetch`, сохраняет результат в `useState`, и потом рендерит `UserList`, прокидывая в него данные. Благодаря такому делению компонент `UserList` легко переиспользовать – хоть для локальных данных, хоть для данных из Redux или context, достаточно написать другой контейнер.

Конечно, не всегда нужно городить пару компонентов вместо одного. Этот паттерн полезен, когда приложение растёт: вы начинаете замечать, что пропсы идут через несколько уровней просто транзитом, или один компонент слишком перегружен логикой. Тогда вы "вытаскиваете" логику в контейнер, а UI – в презентационный компонент, и код сразу становится чище. Это не обязательное правило, а приём для рефакторинга по мере необходимости.

Стоит отметить, что с появлением React-хуков граница между логикой и отображением несколько размылась. Теперь можно выносить логику в кастомные хуки и вызывать их прямо внутри компонента, вместо того чтобы создавать отдельный контейнер-класс, как это делали до 2018 года. Тем не менее, принцип "держи логику отдельно от представления" по-прежнему полезен. Даже с хуками можно структурировать код, разделяя функциональность: написать хук `useUsersData()` для получения пользователей и применять его в разных компонентах (вместо дублирования запроса).

Плюсы: чёткое разделение обязанностей, возможность переиспользовать и заменять части независимо (UI-компонент можно переиспользовать с разными данными), облегчение тестирования.

Минусы: появляется больше файлов/компонентов, чем могло бы быть, что может казаться избыточным для **мелких** случаев. Иногда чрезмерное дробление на "глупые" и "умные" компоненты лишь усложняет структуру, если паттерн применён не к месту. Как говорится, включайте голову – не каждую кнопку нужно выделять в отдельный контейнер.

## 2. Higher-Order Component (HOC)

Когда я впервые услышал термин HOC, он показался мне чем-то из математики. Но на практике всё горадо прозаичнее: HOC – это всего лишь функция, которая принимает React-компонент и возвращает новый компонент, оборачивая исходный дополнительной функциональностью. Проще говоря, HOC – это "обёртка". Мы помещаем один компонент внутрь другого, чтобы на выходе получить расширенную версию переданного в HOC компонента.

Зачем это может понадобиться? Представим, у нас есть несколько разных компонентов, и всем им нужно что-то общее – например, обработка ошибок или подписка на внешние данные. Можно было бы скопировать этот код в каждый из компонентов, но куда элегантнее написать HOC один раз и применить ко всем. Классический пример – Redux-функция `connect`: вы пишете `export default connect(mapState)(MyComponent)`, и ваш компонент получает пропсы из глобального стейта. `connect` как раз и есть HOC, который инъектирует данные из Redux в компонент, не требуя от вас переписывать компоненты под Redux вручную.

Создать свой HOC тоже несложно. Супер банальный пример, сделаем HOC, который добавляет компоненту стейт счётчика:

```jsx
function withCounter(WrappedComponent) {
  // Возвращаем новый компонент-обёртку
  return function WithCounter(props) {
    const [count, setCount] = useState(0);
    // Передаем внутрь исходного компонента счётчик и функцию для увеличения
    return <WrappedComponent count={count} increment={() => setCount(c => c + 1)} {...props} />;
  };
}

// Использование HOC:
function ClickButton({ count, increment, label }) {
  return <button onClick={increment}>{label}: {count}</button>;
}
const EnhancedButton = withCounter(ClickButton);
```

Здесь `withCounter` – HOC, он возвращает новый функциональный компонент `WithCounter`, который внутри себя использует `useState` и передаёт состояние и функцию увеличения внутрь `WrappedComponent`. В итоге `EnhancedButton` – это улучшенная версия `ClickButton`, которая умеет считать клики, даже если исходный `ClickButton` об этом не знал.

Плюсы: один HOC может добавить функциональность множеству компонентов сразу – не надо копировать код везде. Логику можно обновить в одном месте (внутри HOC) – и все обёрнутые компоненты получат изменения. HOC можно комбинировать: например, обернуть компонент сначала в HOC, добавляющий тему оформления, потом в HOC, добавляющий логирование, и т.д. В итоге получим компонент, обладающий сразу несколькими дополнительными возможностями.

Минусы: за такую магию мы платим усложнением структуры. Когда компонентов обёрток становится много, React дерево раздувается, и возникает эффект "матрёшки". В DevTools вы могли видеть что-то вроде: `Connect(withRouter(WithTheme(MyComponent)))` – разобраться, что к чему, становится сложнее. Дебаг таких цепочек – тоже удовольствие то ещё, приходится пробираться через несколько уровней абстракций. Кроме того, HOC часто прокидывают пропсы во внутренний компонент, что чревато конфликтами имён (нужно следить, чтобы, например, `prop.title` от HOC не перезаписал пропс `title`, который вы передали самому компоненту). Ещё нюанс – HOC усложняют типизацию в TypeScript (надо правильно описывать generic для пропсов), но это выходит за рамки нашей темы.

React-разработчики со временем несколько охладели к HOC. В официальной документации прямо сказано: «компоненты высшего порядка не так часто используются в современном React коде». Отчасти их вытеснили хуки (о которых чуть позже). Тем не менее, HOC никуда не делись: их продолжают применять сторонние библиотеки – тот же Redux, Relay и другие до сих пор предлагают API на основе HOC. Да и в старом проекте вы почти наверняка встретите хотя бы пару HOC. Поэтому понимать этот паттерн стоит. Просто имейте в виду современные альтернативы и используйте HOC там, где это действительно необходимо.

## 3. Паттерн Render Props

Следующий паттерн я бы сказал перевёрнутый HOC. Render Props – это подход, когда компонент сам не рендерит что-то внутри себя, а принимает *функцию* (часто через проп `render` или просто используя детей как функцию) и вызывает её, чтобы получить содержимое. То есть мы передаём компоненту инструкцию, *что* именно отрендерить, а он сам обеспечивает *когда* и *с какими данными* вызвать эту инструкцию.

Представьте компонент `<MouseTracker>` для отслеживания положения курсора. Классически он может хранить `x, y` в своём состоянии и отрисовывать, скажем, `<p>Mouse at (x, y)</p>`. Но что если мы хотим переиспользовать эту логику, но уже с другим UI? Паттерн Render Props предлагает сделать компонент `<Mouse>`, который не определяет жёстко JSX внутри себя, а вызывает функцию, переданную через проп (или children функцию), передавая ей координаты. Эта функция сама решит, что рисовать. Таким образом, `<Mouse>` инкапсулирует логику (слежение за мышкой), а отображение делегирует наружу.

Пример: реализуем компонент-утилиту `<FilteredList items={...} filter={...}>`, который отображает список на основе передаваемого фильтра. Вместо того чтобы жёстко прописывать разметку элемента списка, сделаем его с render проп через `children`:

```jsx
function FilteredList({ items, filter, children }) {
  const filtered = items.filter(filter);
  // Вызываем функцию-ребёнка для каждого элемента, оборачивая в <ul>
  return <ul>{filtered.map(item => children(item))}</ul>;
}

// Использование:
<FilteredList items={[1,2,3,4,5]} filter={n => n % 2 === 0}>
  {item => <li key={item}>{item}</li>}
</FilteredList>
```

Здесь `<FilteredList>` знает, как отфильтровать массив (`items.filter(filter)`), но *не* знает, как отрисовать каждый элемент. Вместо этого он вызывает функцию, которую мы передали в качестве дочернего элемента (`children`), для каждого элемента списка. Эта функция возвращает `<li>` для каждого `item`. В результате логика фильтрации инкапсулирована внутри `FilteredList`, а конкретное отображение списка задаётся извне. Мы могли бы так же использовать этот компонент для массива объектов, отрисовывая, например, товары – достаточно передать другую children функцию.

Паттерн Render Props здорово повышает гибкость компонентов. Мы можем переиспользовать `<FilteredList>` для списков чего угодно – чисел, пользователей, товаров – просто изменяя функцию отображения. Другой пример: компонент `<Mouse>` может предоставлять координаты курсора, а внешний код решит, просто вывести текст, нарисовать по координатам картинку, или вызвать какую-то совершенно другую логику – не нужно делать несколько вариаций компонента для каждого кейса.

Плюсы: Render Props позволяет компоненту провайдеру (в примере выше `FilteredList` является провайдером данных) быть максимально универсальным, а конкретную разметку делегировать наружу. Многие библиотеки воспользовались этим паттерном: например, React Router (до версии 6) позволял вместо компонента страницы передать проп `render` в `<Route>` – функцию, которая отрисует JSX на основе параметров маршрута, Formik предлагал компонент `<Formik>` с функцией ребёнком для рендеринга формы, Downshift (библиотека для автокомплитов) – тоже классический пример паттерна render props.

Минусы: главное неудобство – излишний шум в JSX. Код с вложенными функциями бывает тяжело читать. В нашем простом примере всё компактно, но представьте, если у вас будет несколько уровней таких компонентов: `<Foo>{foo => ( <Bar>{bar => ( ... )}</Bar> )}</Foo>` – легко получить "оберточный ад" из стрелочных функций прямо в разметке. Это значительно затруднит отладку такого кода при возникновении каких либо проблем. К тому же, каждый раз при рендере создаётся новая функция, что может негативно сказаться на производительности, если таких компонентов много (React конечно оптимизирует функции в пропсах через механизм сравнения, но всё же). Также возникает неявная связь: внешний код должен знать, какие аргументы ожидает функция. TypeScript конечно помогает, но при чтении кода не сразу видно, что `children`, например, это не просто элемент, а функция.

Как и HOC, паттерн Render Props сейчас используется реже. Многие задачи, решаемые через него, теперь элегантнее с точки зрения кода решаются хуками, в официальной документации это также отмечено. Но всё же, понимать его нужно, потому что легаси код и некоторые библиотеки всё ещё работают на нём. Если видите, что компонент принимает функцию в виде пропса (чаще всего называется `render` или передаваётся через детей), знайте – это он, Render Props.

## 4. Хуки и кастомные хуки

Мы уже несколько раз упоминали хуки (Hooks) – пора поговорить о них как о новом паттерне, фактически пришедшем на смену многим предыдущим. Хуки появились в React 16.8 и моментально изменили стиль написания компонентов. Теперь вместо классов с методами жизненного цикла у нас функциональные компоненты, которые используют состояния (`useState`), эффекты (`useEffect`) и другие возможности прямо внутри функции. А главное – мы можем писать свои собственные, пользовательские хуки (custom hooks), использующие хуки предоставляемые самим React, для повторного использования логики.

Почему же хуки так популярны? Они дают возможность переиспользовать состояние и побочные эффекты, не меняя структуру самих компонентов использующих их. Раньше, чтобы два компонента разделяли какую-то логику, приходилось применять HOC или Render Props – то есть вводить дополнительный компонент-обёртку или коллбэк. Теперь же мы можем вынести логику в custom hook `useSomething()` и вызывать его в нужных нам компонентах. или других кастомных хуках. Получается, что хуки позволяют писать более прямолинейный, читаемый код: вместо закулисной магии HOC мы явно вызываем необходимые нам хуки и получаем данные.

Custom hook – это просто функция, название которой по соглашению начинается с `use` (чтобы линтер React знал, что внутри неё могут быть хуки). Например, давайте перепишем наш HOC `withCounter` из предыдущего примера как кастомный хук:

```jsx
function useCounter(initialValue = 0) {
  const [count, setCount] = useState(initialValue);
  const increment = () => setCount(c => c + 1);
  return { count, increment };
}

// Использование хука в компоненте:
function ClickButton({ label }) {
  const { count, increment } = useCounter();
  return <button onClick={increment}>{label}: {count}</button>;
}
```

Получилось то же самое поведение (счётчик кликов), но без обёрток. Компонент `ClickButton` сам вызывает `useCounter()` и получает `count` и `increment`. Внутри `useCounter` может быть любая другая сложная логика, побочные эффекты, вызовы других хуков – компонент использующий наш хук об этом не знает и не должен знать. Зато код компонента предельно ясный: он просто берёт нужные ему данные из хука и использует их.

Повторное использование логики – главное преимущество кастомных хуков. Вы можете написать, например, хук `useFetch(url)` (достаточно распространённое решение), который будет обращаться к API и возвращать состояние загрузки, успеха запроса, данные и ошибку, если она возникла. Далее можно применять этот хук в разных компонентах, страницах, не дублируя сам код запроса.

Кроме того, хуки отлично работают друг с другом. Вы можете внутри одного хука вызвать другой (например, использовать `useContext` или `useReducer` внутри своего `useAuth` хука). Это помогает облегчить написание сложных функциональностей, т.к. мы используем небольшие хуки выполнящие простые задачи, из которых как конструктор составляем более сложное поведение.

Плюсы: ясность и лаконичность. Мы не оборочиваем компонент использующий хук ни в какие лишние слои, его JSX не замусорен вспомогательными функциями или компонентами, он просто вызывает хукт и получает результаты. HOC и Render Props во многом ушли в прошлое из-за того, что хуки решают те же проблемы более естественным для JavaScript способом. Кастомные хуки легко тестировать (это по сути просто функции). Хуки позволяют разделять логику внутри одного компонента на независимые части: например, компонент может использовать одновременно и свой локальный `useState`, и несколько разных кастомных хуков – каждая часть отвечает за себя, и этот код не переплетается, тогда как при использовании нескольких HOC или Render Props было бы труднее изолировать ответственности.

Минусы: если это можно назвать минусом, то хотя хуки упростили многое, они принесли также свои правила, о которых нужно помнить (вызывать в одном порядке, только в компонентах либо других хуках, не внутри условий). Если нарушить эти правила React выдаст предупреждение или ошибку. Ещё потенциальный минус: повторное использование хука означает, что каждый компонент получает свою копию состояния. Это обычно то что нам нужно, но если вдруг требуется разделять одно состояние между несколькими компонентами – хуки напрямую не помогут, придётся выносить состояние выше (или в контекст, или в стор). Впрочем, это уже другая задача.

В целом, на сегодняшний день хуки основной инструмент в React используемый разработчиками. Большинство новых API, фреймворков, библиотек строятся вокруг хуков. Поэтому если вы видите библиотеку, написанную на HOC либо Render Props, то скорее всего у неё уже есть или появится версия на хуках. Хуки сделали код React компонентов более понятным и можно сказать, свели на нет необходимость в классах (почти все новые фичи React рассчитаны только на функциональные компоненты).

## 5. Compound Components (Составные компоненты)

Паттерны, о которых говорилось выше, касаются того, как компоненты делятся логикой или данными. А есть подход, делающий фокус на композиции компонентов, позволяя создавать гибкие интерфейсы. Compound Components – это паттерн, при котором несколько компонентов работают вместе как единое целое, обмениваясь общим состоянием (обычно через контекст). Пользователь такого "комплекта" компонентов может гибко комбинировать его части в JSX.


Я познакомился с данным паттерном когда писал в качестве пет проекта свой собственный UI Kit. Представьте `<Accordion>` с множеством `<AccordionItem>`, или `<Select>` и `<Option>`. 
Compound Components – это когда мы пишем код таким образом, что компонент `<Accordion>` не 
обязан принимать массив пунктов через пропсы и рендерить его внутри, мы даём 
разработчику возможность самому в JSX расписать, какие пункты будут у аккордеона и что в них будет находиться, 
используя заранее предусмотренные дочерние компоненты: `<Accordion.Item>`, `<Accordion.
Header>` и `<Accordion.Panel>`. 

Возможно у вас как и у меня сразу же возник вопрос в голове: "как же `Accordion` узнает о своих `Item` и организует их работу?" Внутри – как раз при помощи React Context. Compound Components обычно реализуются так: родитель (компонент контейнер) содержит всё состояние (например, какой пункт раскрыт) и методы управления (функция `toggle(index)`). Он оборачивает `children` своим контекст провайдером и передаёт туда эти данные и функции. Дочерние компоненты (которые рендерятся где-то внутри `children`) просто берут нужное из контекста и таким образом получают доступ к состоянию родителя. Они знают, к какому именно контейнеру принадлежат, благодаря тому, что рендерятся внутри него и получают его контекст.

Давайте рассмотрим конкретный пример. Сделаем простой составной компонент `Toggle`, который будет управлять отображением/скрытием некоторого контента по клику. У нас будет `<Toggle>` в роли контейнера и его дочерние компоненты `<Toggle.On>`, `<Toggle.Off>` и `<Toggle.Button>`. 

```jsx
const ToggleContext = createContext();

function Toggle({ children }) {
  const [on, setOn] = useState(false);
  const toggle = () => setOn(prev => !prev);
  return (
    <ToggleContext.Provider value={{ on, toggle }}>
      {children}
    </ToggleContext.Provider>
  );
}

function ToggleOn({ children }) {
  const { on } = useContext(ToggleContext);
  return on ? <>{children}</> : null;
}

function ToggleOff({ children }) {
  const { on } = useContext(ToggleContext);
  return on ? null : <>{children}</>;
}

function ToggleButton({ children }) {
  const { toggle } = useContext(ToggleContext);
  return <button onClick={toggle}>{children}</button>;
}

// Использование:
<Toggle>
  <ToggleOn>Теперь мы видим скрытый текст</ToggleOn>
  <ToggleOff>Текст скрыт</ToggleOff>
  <ToggleButton>Переключить</ToggleButton>
</Toggle>
```

Здесь `<Toggle>` управляет состоянием `on` (показано/скрыто) и предоставляет через контекст значение `{ on, toggle }` всем потомкам. `<ToggleOn>` и `<ToggleOff>` читают `on` и в зависимости от него либо рендерят `children`, либо нет. `<ToggleButton>` получает из контекста функцию `toggle` и вызывает её при клике. В итоге снаружи мы получаем удобный и декларативный интерфейс: внутрь `<Toggle>` мы поместили разные части UI, которые сами знают, когда им отображаться и что делать при клике – мы лишь описали структуру, не связывая их вручную пропсами.

Обратите внимание: компоненту `<Toggle>` без разницы, сколько у него внутри `<ToggleOn>` или `<ToggleOff>`, и какой внутри них JSX. Всё завязано только на состояние контекста. Это и есть сила композиции: пользователю библиотеки даются "кирпичики" (несколько компонентов), из которых он может сложить нужную конструкцию как ему необходимо, а не один монолитный компонент с десятком пропсов настроек.

Плюсы этого паттерна: огромная гибкость и выразительность. Хороший compound компонент ощущается как маленький фреймворк. Например, библиотека @reach/ui (предшественник современной radix-ui) много компонентов строила через этот паттерн: диалоги, списки, выпадающие меню – всё через контекст и вложенные компоненты. Пользователю легко понять API – просто вкладывай одни компоненты в другие. Появляется возможность тонко настроить итоговую разметку, вставить дополнительные элементы если надо, ведь внутри `children` мы не ограничены, можем обернуть тот же `<ToggleButton>` в какой-нибудь `<div>` с нужным классом. Проще поддерживать визуальное единообразие: все части контролируются одним контекстом, не размазывая логику по нескольким несвязанным компонентам.

Минусы: сложнее реализовать. Необходимо аккуратно продумать как компоненты будут взаимодействовать, предусмотреть, что некоторые могут отсутствовать или повторяться. Если неправильно спроектировать составной компонент, можно столкнуться с багами: например, если `<ToggleButton>` случайно использовать вне `<Toggle>` (то есть вне своего провайдера), `useContext` вернёт `undefined` и будет ошибка – надо либо избегать такого, либо делать проверки и бросать понятное сообщение об ошибке (мол, "ToggleButton **ОБЯЗАТЕЛЬНО** должен быть потомком Toggle").

Ещё один момент связан с производительностью, когда контекстное значение меняется, все потребители контекста перерендерятся. Например, при каждом клике `toggle` выше перемонтируются и `<ToggleOn>`, и `<ToggleOff>`, и `<ToggleButton>`. В нашем случае это конечно пустяки, но если бы у нас был десяток сложных для ререндера children'ов подписанных на контекст и состояние менялось часто, нужно было бы подумать об оптимизации (разбивке контекстов или мемоизации).

Тем не менее, плюсы обычно перевешивают: паттерн Compound Components позволяет создать очень понятный и гибкий пользовательский API для ваших компонентов. Это проявление философии React – композиция важнее наследования. Вместо того чтобы делать сложный компонент с кучей условий, мы делаем набор простых компонентов, которые в комбинации собираются в сложное поведение.

Compound Components – довольно "профессиональный" паттерн. В небольших приложениях вы можете не столкнуться с необходимостью его реализовывать, но если разрабатываете библиотеку компонентов как я в своём пет проекте или сложный виджет, такой подход становится для вас чуть ли не необходимостью. Практически все продвинутые React UI-библиотеки (Material UI, Chakra, Radix и т.д.) используют контекст и композицию под капотом для своих сложных компонентов.

## 6. Серверные компоненты и Suspense: современные возможности React

Наконец, давайте поговорим о новейших возможностях, которые принесли нам React 18 и React 19. Они направлены на улучшение работы с асинхронностью, данными и рендерингом на стороне сервера. В первую очередь это React Suspense и Server Components. Эти вещи ещё не до конца устоялись в среде разработчиков, но их стоит держать в уме.

### Suspense – ожидание с комфортом

Когда интерфейсу нужно загрузить данные, всегда возникает задача – показать индикатор загрузки, пока всё не готово. Раньше приходилось вручную писать логику, часто это бывало состояние `isLoading` и условный рендер либо спиннера, либо контента. С появлением React Suspense командой React был предложен более декларативный способ. Suspense – это специальный компонент, который позволяет нам приостановить рендеринг своих дочерних компонентов, пока те не готовы, и в это время показать fallback UI.

Проще говоря, мы оборачиваем часть дерева компонентов в `<Suspense fallback={<Loader/>}> ... </Suspense>`, и если внутри этой области происходит задержка (например, идёт загрузка кода или данных), React сам автоматически покажет `<Loader>` вместо содержимого, а когда всё завершится – отобразит наши компоненты. Suspense берёт на себя координацию этого процесса, освобождая нас от ручного управления состоянием загрузки.

На сегодня Suspense широко используется для ленивой загрузки компонентов (`React.lazy` + `<Suspense>`). Например:

```jsx
const Comments = React.lazy(() => import('./Comments'));

function ArticlePage() {
  return (
    <div>
      {/* ... содержимое статьи ... */}
      <Suspense fallback={<div>Комментарии загружаются...</div>}>
        <Comments postId={666} />
      </Suspense>
    </div>
  );
}
```

Здесь компонент `Comments` будет подгружён по требованию (и в отдельном бандле). Пока бандл не загрузится, пользователь увидит текст заглушку "Комментарии загружаются...". Как только код придет, React отрисует `<Comments>`. Всё это без какого-либо специального кода внутри `ArticlePage` для отслеживания загрузки – Suspense сам разрулит ситуацию: `React.lazy` под капотом бросает Promise на время загрузки, а `<Suspense>` ловит его и показывает фоллбэк.

Кроме ленивой загрузки кода, Suspense постепенно начинает применяться и для асинхронных данных. В React 18 появился экспериментальный API, позволяющий Suspense работать с данными, например, можно использовать специальный `use` для ожидания промиса прямо внутри компонента (пока официально не стабильно, но фреймворки типа Next.js 13 уже вовсю используют это). Идея та же: компонент, который загружает данные, вместо того чтобы сразу вернуть JSX, может "suspend" – приостановить своё выполнение до получения данных. React, обнаружив это, покажет fallback, а когда данные придут – продолжит рендер компонента. Таким образом, можно писать компонент, который выглядит синхронным, хотя внутри у него асинхронный код – за счёт Suspense'а пользователю не покажется незавершённый результат.

Признаться, Suspense для работы с данными – пока что из области экспериментов. Если вы пишете обычное приложение на Vite или Боже упаси, CRA, без Next, то прямо сейчас использовать Suspense для загрузки данных "из коробки" не выйдет – потребуется либо сторонняя библиотека (например, React Query пока не интегрирован с Suspense по умолчанию, но планирует), либо фреймворк. Однако направление понятное: React движется к тому, чтобы сделать работу с асинхронностью более декларативной. Уже сейчас вы можете использовать Suspense для спиннеров и заглушек при загрузке кода, а в ближайшем будущем, вероятно, подобный подход станет нормой и для данных.

Подводя итог по Suspense: этот паттерн позволяет очень аккуратно организовать отображение состояния загрузки. Вместо большого количества условных `isLoading ? <Spinner> : <Content>` мы просто заявляем: "Эта часть UI может задержаться, показывай пока вот это". Это улучшает UX (пользователь видит скелетон или лоадер без моргания незагруженного контента) и упрощает код. Обязательно следим за развитием Suspense – возможно, скоро он будет использоваться намного чаще, чем сейчас.

## Серверные компоненты – React выходит на сервер

Ещё одна революционная идея команды React, это React Server Components (RSC) или серверные компоненты. Это попытка объединить лучшее из мира серверного рендеринга и клиентских SPA. Смысл в том, что если часть ваших React компонентов может выполняться только на сервере, генерируя готовый HTML, который отправляется клиенту, то пусть они и исполняются на сервере, не загружая клиент. Эти компоненты никогда не попадают в бандл JS, не несут в себе интерактива – они чисто для рендеринга контента. Другая часть компонентов всё также остаётся клиентской, это давно знакомые нам React компоненты, которые умеют обрабатывать события, имеют какое-то своё состояние и т.д. Разделение происходит явно: React различает, какой компонент предназначен для сервера, а какой для клиента.

Как же React понимает, в какой среде выполнять код компонента? Введена директива `"use client"`: если файл компонента начинается с этой строки, то компонент клиентский, он будет собран в JS и выполнится в браузере. Если же такой строчки нет – компонент считается серверным и по умолчанию выполнится на сервере (например, при рендеринге страницы на Node.js). Серверный компонент может содержать асинхронный код (запросы к БД, файловой системе и т.п.), ведь он запускается в среде сервера. Но он не может использовать, например, `useState` или `useEffect`, ведь у него нет постоянного состояния между запросами, да и доступ к DOM он не имеет.

React 18 (и в полной мере React 19) позволяют фреймворкам использовать эту возможность. Например, Next.js 13 с новым `app/` роутером делает все компоненты по умолчанию серверными, если не указать "use client". Таким образом, большую часть страницы вы можете рендерить на сервере, отдавая сразу на клиент сразу готовую разметку, а для интерактивных элементов использовать клиентские компоненты.

Преимущества Server Components: во-первых, производительность. Серверные компоненты избегают гидрации, клиенту не нужно повторно исполнять JS, чтобы восстановить состояние UI. Вы получаете выгоды SSR (быстрый первый рендер, минимум работы на клиенте) без обычных недостатков SSR (необходимость гидрации большого объёма HTML). Во-вторых, безопасность: чувствительный код остается на сервере, не попадает в бандл, и данные можно получать напрямую на сервере (например, напрямую из базы) без передачи ключей API в браузере. В-третьих, размер бандла существенно сокращается, ведь клиент вообще не получает код серверных компонентов, только итоговую HTML разметку и нужный JS для оставшихся клиентских компонентов.

Как это выглядит на практике? Самый понятный пример. Представим блог. Страницу поста можно сделать целиком серверным компонентом, на сервере загрузится пост из БД и вернёт нам готовую верстку статьи. А вот кнопка лайка или форма добавления комментария – это уже интерактив, их делаем клиентскими компонентами. В результате пользователь, заходя на страницу, сразу же получит полностью готовую страницу поста (никакого лоадера, всё пререндерено). А JS код загрузится только для кнопки лайка и формы комментария, и только они гидрируются и начинают работать на клиенте. Это сочетание SSR и SPA, orchestrated by React.

React строго определяет, как серверные и клиентские компоненты могут взаимодействовать. Серверный компонент может импортировать и использовать другой серверный или клиентский компонент, а вот клиентский компонент не может импортировать серверный. То есть дерево может быть: Серверный -> внутри него Клиентский -> внутри него ещё Клиентский и т.д. Но не наоборот. В примере выше, серверный компонент страницы может рендерить внутри себя `<LikeButton />` (клиентский компонент кнопки). А если бы вы попробовали внутри клиентского компонента сделать `import PostDetails from './PostDetails.server.jsx'` – сборка не позволит, скажет что так нельзя. Таким образом, архитектура разделяется: "верхние" уровни страницы – серверные, "листья" интерактивности – клиентские.

Server Components – это пока что прерогатива фреймворков. То есть в обычном приложении вы вручную не сможете этим воспользоваться без большого труда. Но если вы работаете с Next.js, Remix, или в целом fullstack React приложениями, то RSC уже доступны. В React 18 это скорее эксперимент для энтузиастов. Библиотеки тоже начинают подстраиваться: например, React Router v7 планирует поддерживать RSC, Vite тоже экспериментирует с этим.

Что в итоге нам дают серверные компоненты? Потенциально, большой скачок в производительности и удобстве разработки fullstack приложений. Мы получаем паттерн разделения по среде: какие компоненты должны рендериться на сервере, а какие на клиенте. Это новое измерение при проектировании React приложения. Разработчику теперь нужно будет думать не только о разделении логики и UI, или о переиспользовании кода, но и решать где лучше выполнить тот или иной код – на сервере или в браузере. Правильное использование RSC может значительно ускорить приложение без лишних усилий для разработчика (React сам решит, когда и что подгружать, синхронизирует состояние между сервером и клиентом).

С другой стороны, появляется дополнительная сложность в понимании: нужно чётко осознавать ограничения (например, нельзя в серверном компоненте использовать `useEffect`, или что состояние в серверном компоненте не сохраняется между запросами). Но это всё решаемо практикой и хорошей документацией.

## Заключение

Мы рассмотрели ключевые паттерны React и даже заглянули в будущее React архитектур. Container & Presentational Components привносят порядок, отделяя логику от отображения. HOC и Render Props – старые приёмы для переиспользования кода, которые в значительной мере вытеснены более современными хуками, но по прежнему встречаются в проектах. Compound Components демонстрируют силу композиции, предоставляя API для гибкой сборки компонентов из небольших частей. А Suspense и Server Components – это уже ближайшее будущее, делающее работу с асинхронностью и рендерингом более эффективной и декларативной.

Важно понимать, что паттерны это не нерушимые догмы. В каждом конкретном случае их нужно применять с умом. Порой проще обойтись без паттерна, чем усложнять архитектуру ради "красивого" решения. Не нужно в лишний раз оверинженирить. Однако знание этих подходов обогащает ваш инструментарий. Когда вы сталкиваетесь с определённой проблемой, на подкорке всплывёт: "ага, здесь бы подошёл такой-то паттерн!" Опытный разработчик видит несколько вариантов реализации и выбирает оптимальный.

От себя добавлю: изучая паттерны, всегда пробуйте их в деле. Напишите свой HOC, переделайте компонент с Render Props на хук, реализуйте небольшой набор Compound Components – так вы прочувствуете их сильные и слабые стороны. React развивается, и появляются новые приёмы, но фундаментальные идеи (композиция, разделение обязанностей, явное управление состоянием) остаются. Владейте этими инструментами – и ваши React приложения будут благодарить вас чистотой и поддерживаемостью кода!

