# Различные дизайн-паттерны в React

В мире React термин "паттерн" означает проверенный подход к решению типовой задачи, а не шаблон проектирования из классической книги. За годы разработки вокруг React сформировались свои распространённые дизайн-паттерны – способы организовать компоненты и логику так, чтобы код получался понятным, поддерживаемым и многократно используемым.

В этой статье я, как опытный React-разработчик, расскажу о пяти самых популярных паттернах, с примерами кода на современных функциях React (хуки, функциональные компоненты), обсужу, когда каждый из них пригодится, а также отмечу их плюсы и минусы. Поговорим о классических приёмах вроде контейнеров и HOC, эволюции к хукам, и о том, какие новые паттерны появились в свежих версиях React – например, Server Components и Suspense из React 18/19. Присаживайтесь поудобнее, будет интересно и по делу!

## 1. Компоненты-контейнеры и презентационные компоненты

Когда я только начал писать на React, мой код часто представлял собой огромные компоненты, которые и данные из API тянут, и JSX с кучей разметки возвращают. Слышали выражение "разделяй и властвуй"? Паттерн Container & Presentational Components (контейнерные и презентационные компоненты) ровно об этом: он разделяет логику (данные) и отображение (UI) на разные компоненты.

Презентационные компоненты отвечают только за то, *как* что-то выглядит. Они получают данные через `props` и красиво отображают их, не задумываясь, откуда те взялись. Это, как правило, чистые функциональные компоненты, часто без собственного состояния (разве что мелкий UI-стейт типа "раскрыт ли dropdown"). Им всё равно, где взять список пользователей – они просто ожидают `props.users` и рисуют, например, список.

Контейнерные компоненты, напротив, знают *что* показать и *откуда* это взять, но не занимаются тем, *как* это отображается. Они содержат в себе всю логику: могут загрузить данные, подписаться на store или контекст, хранят состояние, а рендерят в основном других – презентационных – потомков, передавая им готовые данные. Контейнер может вообще не выдавать собственного HTML, кроме того, что приходит от дочернего презентационного компонента. Его задача – быть прослойкой между источником данных и визуальным компонентом.

Зачем нужен такой расклад? Во-первых, лучшая разделённость ответственности (UI отдельно, данные отдельно) упрощает понимание и сопровождение приложения. Во-вторых, улучшается повторное использование: один презентационный компонент можно подключить к разным источникам данных через разные контейнеры. Дизайнеры могут менять внешний вид компонента в одном месте, не затрагивая бизнес-логику. И тестировать тоже проще: можно отдельно протестировать логику контейнера (без верстки) и отдельно презентационный компонент (с моком данных).

```jsx
// Пример: презентационный компонент списка пользователей
function UserList({ users }) {
  return (
    <ul>
      {users.map(user => (
        <li key={user.id}>{user.name}</li>
      ))}
    </ul>
  );
}

// Контейнерный компонент, загружающий пользователей
function UserListContainer() {
  const [users, setUsers] = React.useState([]);
  
  React.useEffect(() => {
    fetch('/api/users')
      .then(res => res.json())
      .then(data => setUsers(data));
  }, []);
  
  return <UserList users={users} />;
}
```

В этом примере `UserList` не содержит ничего, кроме отображения списка. Ему всё равно, как и где получают пользователей – он просто принимает проп `users` и выводит их. Контейнер `UserListContainer` занимается побочными эффектами: делает `fetch`, сохраняет результат в `useState`, и потом рендерит `UserList`, прокидывая данные. Благодаря такому делению компонент `UserList` легко переиспользовать – хоть для локальных данных, хоть для данных из Redux или Context, достаточно написать другой контейнер.

Конечно, не всегда нужно городить пару компонентов вместо одного. Этот паттерн особенно полезен, когда приложение растёт: вы начинаете замечать, что пропсы идут через несколько уровней просто транзитом, или один компонент слишком перегружен логикой. Тогда вы "вытаскиваете" логику в контейнер, а UI – в презентационный компонент, и сразу становится чище. Это не обязательное правило, а приём для рефакторинга по мере необходимости.

Стоит отметить, что с появлением React-хуков граница между логикой и отображением несколько размылась. Теперь можно выносить логику в кастомные хуки и вызывать их прямо внутри компонента, вместо того чтобы создавать отдельный контейнер-класс, как это делали до 2018 года. Многие современные компоненты сами и данные могут подгрузить (через `useEffect`), и отрисовать их – и это нормально. Тем не менее, принцип "держи логику отдельно от представления" по-прежнему полезен. Даже с хуками вы можете структурировать код, разделяя функциональность: например, написать хук `useUsersData()` для получения пользователей и применять его в разных компонентах (вместо дублирования запроса).

Плюсы: чёткое разделение обязанностей, возможность переиспользовать и заменять части независимо (UI-компонент можно переиспользовать с разными данными), облегчение тестирования и сопровождения кода.

Минусы: появляется больше файлов/компонентов, чем могло бы быть, что может казаться избыточным для мелких случаев. Иногда чрезмерное дробление на "глупые" и "умные" компоненты лишь усложняет структуру, если паттерн применён не к месту. Как говорится, включайте голову – не каждую кнопку нужно выделять в отдельный контейнер.

В целом, Container/Presentational – фундаментальный паттерн, с которого исторически начиналось строительство крупномасштабных React-приложений. Хотя сейчас у нас есть и другие способы организации (тот же контекст или хуки), идея разделения логики и представления остаётся ключевой.

## 2. Компоненты высшего порядка (HOC)

Когда я впервые услышал термин HOC (Higher-Order Component), он показался чем-то из математики. Но на практике всё проще: HOC – это функция, которая принимает React-компонент и возвращает новый компонент, оборачивая исходный дополнительной функциональностью. Проще говоря, HOC – это "обёртка" (некоторые шутят – компонент-матрёшка). Мы помещаем один компонент внутрь другого, чтобы на выходе получить расширенную версию.

Зачем это может понадобиться? Представьте, у нас есть несколько разных компонентов, и всем им нужно что-то общее – например, логирование, обработка ошибок или подписка на внешние данные. Можно было бы скопировать этот код в каждый, но куда элегантнее написать HOC один раз и применить ко всем. Классический пример – Redux-функция `connect`: вы пишете `export default connect(mapState)(MyComponent)`, и ваш компонент получает пропсы из глобального стейта. `connect` как раз и есть HOC, который инъектирует данные из Redux в компонент, не требуя от вас переписывать компоненты под Redux вручную.

Создать свой HOC тоже несложно. Например, сделаем HOC, который добавляет компоненту состояние счётчика:

```jsx
function withCounter(WrappedComponent) {
  // Возвращаем новый компонент-обёртку
  return function WithCounter(props) {
    const [count, setCount] = React.useState(0);
    // Передаем внутрь исходного компонента счётчик и функцию для увеличения
    return <WrappedComponent count={count} increment={() => setCount(c => c + 1)} {...props} />;
  };
}

// Использование HOC:
function ClickButton({ count, increment, label }) {
  return <button onClick={increment}>{label}: {count}</button>;
}
const EnhancedButton = withCounter(ClickButton);
```

Здесь `withCounter` – HOC, он возвращает новый функциональный компонент `WithCounter`, который внутри себя использует `useState` и передаёт состояние и функцию увеличения внутрь `WrappedComponent`. В итоге `EnhancedButton` – это улучшенная версия `ClickButton`, которая умеет считать клики, даже если исходный `ClickButton` об этом не знал.

HOC активно применялись для повторного использования логики. Они позволяют абстрагировать общий код "снаружи" компонентов. Помимо подключения к Redux, были и другие примеры: в React Router раньше существовал HOC `withRouter` (для передачи параметров маршрута в компонент), есть HOC для обработки ошибок (оборачивает компонент и ловит ошибки в методе жизненного цикла, показывая fallback UI), HOC для авторизации (проверяет права доступа и либо рендерит компонент, либо редиректит). Все эти варианты – проявления одного подхода: функция-обёртка добавляет компоненту общие способности.

Плюсы: один HOC может добавить новую функциональность множеству компонентов сразу – не надо копировать код везде. Логику можно обновить в одном месте (внутри HOC) – и все обёрнутые компоненты получат изменения. HOC можно комбинировать: например, обернуть компонент сначала в HOC, добавляющий тему оформления, потом в HOC, добавляющий логирование, и т.д. В итоге получим компонент, обладающий сразу несколькими дополнительными возможностями.

Минусы: за такую магию платим усложнением структуры. Когда компонентов-обёрток становится много, React-дерево раздувается, и возникает эффект "матрёшки". В DevTools вы могли видеть что-то вроде: `Connect(withRouter(WithTheme(MyComponent)))` – разобраться, что к чему, становится сложнее. Дебаг таких цепочек – тоже удовольствие ниже среднего, приходится пробираться через несколько уровней абстракций. Кроме того, HOC часто прокидывают пропсы во внутренний компонент, что чревато конфликтами имён (нужно следить, чтобы, например, `prop.title` от HOC не перезаписал пропс `title`, который вы передали самому компоненту). Ещё нюанс – HOC усложняют типизацию в TypeScript (надо правильно описывать generic для пропсов), но это выходит за рамки нашей темы.

React-разработчики со временем несколько охладели к HOC. В официальной документации прямо сказано: «компоненты высшего порядка не так часто используются в современном React-коде». Отчасти их вытеснили хуки (о которых чуть позже). Тем не менее, HOC никуда не делись: их продолжают применять сторонние библиотеки – тот же Redux, Relay и другие до сих пор предлагают API на основе HOC. Да и в старом проекте вы почти наверняка встретите хотя бы пару HOC. Поэтому понимать этот паттерн стоит. Просто имейте в виду современные альтернативы и применяйте HOC взвешенно.

## 3. Паттерн Render Props

Следующий паттерн – будто перевёрнутый HOC. Render Props – это подход, когда компонент не сам рендерит что-то жёстко внутри себя, а принимает *функцию* (часто через проп `render` или просто используя детей как функцию) и вызывает её, чтобы получить содержимое. То есть мы передаём компоненту инструкцию, *что* именно отрендерить, а он сам обеспечивает *когда* и *с какими данными* вызвать эту инструкцию.

Представьте компонент `<MouseTracker>` для отслеживания положения курсора. Классически он может хранить `x, y` в своём состоянии и отрисовывать, скажем, `<p>Mouse at (x, y)</p>`. Но что если нам нужно переиспользовать эту логику в другом UI? Паттерн Render Props предлагает сделать компонент `<Mouse>`, который не определяет жёстко JSX внутри, а вызывает функцию, переданную через проп (или children-функцию), передавая ей координаты. Эта функция сама решит, что рисовать. Таким образом, `<Mouse>` инкапсулирует логику (следит за мышью), а отображение делегирует наружу.

Пример: реализуем компонент-утилиту `<FilteredList items={...} filter={...}>`, который отображает список на основе фильтра. Вместо того чтобы жёстко прописывать разметку элемента списка, сделаем его с render-проп через `children`:

```jsx
function FilteredList({ items, filter, children }) {
  const filtered = items.filter(filter);
  // Вызываем функцию-ребёнка для каждого элемента, оборачивая в <ul>
  return <ul>{filtered.map(item => children(item))}</ul>;
}

// Использование:
<FilteredList items={[1,2,3,4,5]} filter={n => n % 2 === 0}>
  {item => <li>{item}</li>}
</FilteredList>
```

Здесь `<FilteredList>` знает, как отфильтровать массив (`items.filter(filter)`), но *не* знает, как отрисовать каждый элемент. Вместо этого он вызывает функцию, которую мы передали в качестве дочернего элемента (`children`), для каждого элемента списка. Эта функция возвращает `<li>` для каждого `item`. В результате логика фильтрации инкапсулирована внутри `FilteredList`, а конкретное отображение списка задаётся извне. Мы могли бы так же использовать этот компонент для массива объектов, отрисовывая, например, карточки – достаточно передать другую функцию ребёнка.

Паттерн Render Props здорово повышает гибкость компонентов. Мы можем переиспользовать `<FilteredList>` для списков чего угодно – чисел, пользователей, товаров – просто меняя функцию отображения. Другой пример: компонент `<Mouse>` может предоставлять координаты курсора, а внешний код решит, нарисовать ли по ним картинку, вывести текст или вызвать какую-то логику – не нужно делать несколько вариантов компонента для каждого случая.

Плюсы: Render Props позволяет компоненту-провайдеру (в примере выше `FilteredList` выступает провайдером данных) быть максимально универсальным, а конкретную разметку делегировать наружу. Это удобно для создания переиспользуемых логических компонентов. Многие библиотеки воспользовались этим паттерном: например, React Router (до версии 6) позволял вместо компонента страницы передать проп `render` в `<Route>` – функцию, которая отрисует JSX на основе параметров маршрута, Formik (библиотека форм) предлагала компонент `<Formik>` с функцией-ребёнком для рендеринга формы, Downshift (библиотека для автокомплитов) – тоже классический пример паттерна render props.

Минусы: главное неудобство – шум в JSX. Код с вложенными функциями бывает тяжеловато читать. В нашем простом примере всё компактно, но представьте, если у вас несколько уровней таких компонентов: `<Foo>{foo => ( <Bar>{bar => ( ... )}</Bar> )}</Foo>` – легко получить "оберточный ад" из стрелочных функций прямо в разметке. Это затрудняет отладку. К тому же, каждый раз при рендере создаётся новая функция, что может негативно сказаться на производительности, если таких компонентов много (React, впрочем, оптимизирует функции в пропсах через механизм сравнения, но всё же). Также возникает неявная связь: внешний код должен знать, какие аргументы ожидает функция. TypeScript помогает, но при чтении кода сразу не видно, что, скажем, `children` – это не просто элемент, а функция.

Как и HOC, паттерн Render Props сейчас используется реже. Многие задачи, решаемые через него, теперь элегантнее решаются хуками. В официальной документации отмечено, что Render Props применяются в современном React нечасто, и во многих случаях их заменяют кастомные хуки. Тем не менее, понимать его стоит, потому что старый код и некоторые библиотеки всё ещё на нём основаны. Если видите, что компонент принимает функцию в виде пропса (чаще всего называемого `render` или передаваемого через детей), знайте – это оно, Render Props.

## 4. Хуки и кастомные хуки

Мы несколько раз упоминали хуки (Hooks) – пора поговорить о них как о новом паттерне, фактически пришедшем на смену многим предыдущим. Хуки появились в React 16.8 и сразу изменили стиль написания компонентов. Теперь вместо классов с методами жизненного цикла у нас функциональные компоненты, которые могут использовать состояния (`useState`), эффекты (`useEffect`) и другие возможности прямо внутри функции. А главное – мы можем писать пользовательские хуки (custom hooks), то есть свои функции, использующие хуки, для выделения и повторного использования логики.

Почему хуки так популярны? Они дают возможность переиспользовать состояние и побочные эффекты, не меняя структуру компонентов. Раньше, чтобы два компонента разделяли какую-то stateful-логику, приходилось применять HOC или Render Props – то есть вводить дополнительный компонент-обёртку или колбэк. Теперь же можно вынести логику в функцию `useSomething()` и вызывать её в нужных компонентах. Получается, что хуки позволяют писать более прямолинейный, читаемый код: вместо закулисной магии HOC мы явно вызываем функции и получаем данные.

Custom hook – это просто функция, название которой по соглашению начинается с `use` (чтобы линтер React знал, что внутри неё могут быть хуки). Например, давайте перепишем наш HOC `withCounter` из предыдущего примера как кастомный хук:

```jsx
function useCounter(initialValue = 0) {
  const [count, setCount] = React.useState(initialValue);
  const increment = () => setCount(c => c + 1);
  return { count, increment };
}

// Использование хука в компоненте:
function ClickButton({ label }) {
  const { count, increment } = useCounter();
  return <button onClick={increment}>{label}: {count}</button>;
}
```

Получилось то же самое поведение (счётчик кликов), но без обёрток. `ClickButton` сам вызывает `useCounter()` и получает `count` и `increment`. Внутри `useCounter` может быть любая сложная логика, вызовы других хуков, побочные эффекты – внешний компонент об этом не знает. Зато код компонента предельно ясный: он просто берёт нужные ему данные из хука и использует их.

Повторное использование логики – главное преимущество кастомных хуков. Вы можете написать, например, хук `useFetch(url)`, который будет обращаться к API и возвращать состояние загрузки, данные и ошибку. И применять его в разных компонентах, не дублируя код запроса. Или `useFormFields(initialState)` – хук для управления состоянием формы (возвращает объект значений полей и функцию для обновления по имени поля). По сути, хуки позволяют реализовать всё то, для чего раньше приходилось прибегать к HOC или Render Props, но сделать это более изящно и с меньшим количеством кода.

Кроме того, хуки прекрасно сочетаются между собой – вы можете внутри одного хука вызвать другой (например, использовать `useContext` или `useReducer` внутри своего `useAuth` хука). Это облегчает композицию функциональности: небольшие узкоспециализированные хуки выполняют простые задачи, а из них можно составлять более сложное поведение.

Плюсы: лаконичность и ясность. Компонент, использующий хук, не обёрнут лишними слоями, его JSX не замусорен вспомогательными функциями или компонентами – он просто вызывает функции и получает результаты. HOC и Render Props во многом ушли в прошлое, потому что хуки решают ту же проблему более естественным для JavaScript способом. Кастомные хуки легко тестировать (это просто функции). Кроме того, хуки позволяют разделять логику внутри одного компонента на независимые части: например, компонент может использовать одновременно и `useState`, и несколько разных кастомных хуков – каждое отвечает за своё, и этот код не переплетается, тогда как при использовании нескольких HOC или Render Props было бы труднее так изолировать ответственности.

Минусы: хотя хуки упростили многое, они принесли свои правила, о которых нужно помнить – правила хуков (вызывать в одном порядке, только в компонентах/хуках, не внутри условий). Если их нарушить, React выдаст предупреждение или ошибку. Ещё потенциальный минус: повторное использование через хук означает, что каждый компонент получает свою копию состояния. Это обычно то, что нужно, но если вдруг требуется разделять одно состояние между несколькими компонентами – хуки напрямую не помогут, придётся выносить состояние выше (или в контекст, или в глобальный стор). Впрочем, это уже другая задача.

В целом, хуки сегодня – основной инструмент в React. Большинство новых API, фреймворков, библиотек строятся вокруг хуков. Поэтому если вы видите библиотеку, написанную на HOC или Render Props, скорее всего у неё уже есть или появится версия на хуках. Хуки сделали код React-компонентов более плоским и понятным, и, можно сказать, свели на нет необходимость в классах (почти все новые фичи React рассчитаны только на функциональные компоненты).

## 5. Context API (паттерн «Provider»)

Переходим к ещё одному широко применяемому паттерну – Context API. Это встроенный механизм React, позволяющий передавать данные через всё дерево компонентов, не прокидывая пропсы вручную на каждом уровне. Проще говоря, контекст – это глобальная переменная для дерева компонентов, где родитель может предоставить значение, а любой глубоко вложенный потомок – получить его напрямую, минуя промежуточных родителей.

Контекст решает проблему "prop drilling" – когда мы вынуждены передавать одни и те же пропсы через множество компонентов, которые сами эти пропсы даже не используют, а только пробрасывают дальше. В какой-то момент такой код становится тяжело поддерживать: стоит поменять структуру пропса – и нужно поправить десяток промежуточных компонентов. Context API избавляет от этого, позволяя объявить данные на верхнем уровне и использовать их внизу без явной передачи.

Как это выглядит? Сначала создаём контекст: `const MyContext = React.createContext(defaultValue)`. Затем на уровне провайдера пишем `<MyContext.Provider value={...}>` и вкладываем в него дочерние компоненты, которые должны иметь доступ к значению. Любой потомок внутри может получить это значение, вызвав `useContext(MyContext)` (или через `<MyContext.Consumer>` в старом API). Таким образом, данные "настраиваются" один раз и доступны многим компонентам.

Когда применять контекст: классические примеры – тема оформления приложения (light/dark theme), текущий залогиненный пользователь, настройки локализации, корзина в интернет-магазине и т.п. То есть что-то глобальное для интерфейса, что нужно многим компонентам на разных уровнях. Например, можно создать `ThemeContext` и предоставить в нём объект с цветовой темой, а глубоко внутри, скажем, компонента `Button` просто вызвать `const theme = useContext(ThemeContext)` и получить текущий цвет, не проводя этот цвет через все промежуточные компоненты между `App` и `Button`.

Контекст также часто используют для реализации паттерна Compound Components (составных компонентов), о котором дальше, – он позволяет связанным компонентам обмениваться состоянием без пропсов. И, кроме того, многие внешние состояния (Redux, MobX) под капотом используют Context: например, Redux `Provider` использует контекст, чтобы передать хранилище всем `connect`-нутым компонентам.

Пример использования контекста:

```jsx
// Создаем контекст для условного авторизованного пользователя
const AuthContext = React.createContext();

// Компонент-провайдер, оборачивающий приложение
function AuthProvider({ children }) {
  const [user, setUser] = React.useState(null);
  const login = name => setUser({ name });
  const logout = () => setUser(null);
  const value = { user, login, logout }; // то, что будет доступно потомкам

  return <AuthContext.Provider value={value}>{children}</AuthContext.Provider>;
}

// Где-то глубоко в дереве:
function UserProfile() {
  const { user, logout } = React.useContext(AuthContext);
  if (!user) return <div>Не вошли</div>;
  return (
    <div>
      Привет, {user.name}! <button onClick={logout}>Выйти</button>
    </div>
  );
}
```

Здесь `AuthProvider` предоставляет контекст с текущим пользователем и функциями входа/выхода. Компонент `UserProfile` никак не получает эти данные через пропсы – он напрямую берёт их из `AuthContext`. Добавили бы ещё уровни компонентов между ними – ничего менять не пришлось бы: промежуточные уровни просто не участвуют в передаче этих данных.

Плюсы: избавляет от необходимости пробрасывать пропсы через много уровней (устраняет "prop drilling"), облегчает доступ к глобальным данным. Очень удобно для настроек, тем, текущего состояния приложения, когда много компонентов должны знать одно и то же. Паттерн "Provider" (контекст + компонент-обёртка, предоставляющий значение) – один из 
краеугольных в React-приложениях: мы оборачиваем дерево провайдерами различных контекстов 
(темы, пользователя, роутера и т.д.), а внутри компоненты потребляют нужные данные через 
`useContext`. 

Минусы: у контекста есть подводные камни. Главное – не злоупотреблять. Если начать пихать в контекст всё подряд, можно получить ситуацию, когда любое изменение данных контекста вызывает повторный рендер у всех компонентов-потребителей, что чревато просадкой производительности. Решение – разбивать данные по разным контекстам и оптимизировать `shouldComponentUpdate`/`React.memo` при необходимости. Также, контекст – глобальная по сути вещь, поэтому компоненты, его потребляющие, труднее использовать изолированно (их всегда нужно рендерить под соответствующим провайдером). Например, наш `UserProfile` нельзя просто взять и использовать отдельно – он зависит от `AuthContext`. (Можно, конечно, предусмотреть дефолтное значение контекста, но все же связь остаётся.)

Наконец, React официально предупреждает, что Context API не является полной заменой для специализированных библиотек менеджмента состояния в больших приложениях. Контекст отлично подходит для передачи относительно статичных данных или слабо изменяющегося состояния на небольшой глубине, но если у вас огромное приложение с десятками видов состояния, сложной логикой обновления – вероятно, лучше посмотреть в сторону Redux/Zustand/Jotai и им подобных, которые предлагают доп. возможности (средства оптимизации, структуры хранилища и т.п.).

В целом, контекст – мощный инструмент, который существенно упростил передачу данных начиная с React 16.3, а с хуками им стало пользоваться ещё удобнее. Почти в каждом приложении React вы найдёте где-то парочку контекстов. Понимание паттерна "провайдер + потребитель" абсолютно необходимо для опытного React-разработчика.

## 6. Составные компоненты (Compound Components) и композиция

Паттерны, о которых говорилось выше, касаются того, как компоненты делятся логикой или данными. А есть подход, фокусирующийся на композиции компонентов для создания гибких интерфейсов. Compound Components – это паттерн, при котором несколько компонентов работают вместе как единое целое, обмениваясь общим состоянием (обычно через контекст). Пользователь такого "комплекта" может гибко комбинировать его части в JSX.

Представьте `<Accordion>` с множеством `<AccordionItem>`, или `<Select>` и `<Option>`. 
Составной компонент – это когда мы делаем, например, компонент `<Accordion>`, но не 
заставляем его принимать массив пунктов через пропсы и рендерить их внутри, а даём 
разработчику возможность самому в JSX расписать, какие будут пункты аккордеона и что в них, 
используя заранее предусмотренные дочерние компоненты: `<Accordion.Item>`, `<Accordion.
Header>` и `<Accordion.Panel>`. 

Как же `Accordion` узнает о своих `Item` и координирует их работу? Внутри – как раз при помощи React Context. Compound Components обычно реализуются так: родитель (компонент-контейнер) содержит всё состояние (например, какой пункт раскрыт) и методы управления (например, функция `toggle(index)`). Он оборачивает `props.children` своим контекст-провайдером и передаёт туда эти данные и функции. Дочерние компоненты (которые рендерятся где-то внутри `children`) просто берут нужное из контекста – и таким образом получают доступ к состоянию родителя. Они как бы "знают", к какому контейнеру принадлежат, за счёт того, что рендерятся внутри него и получают его контекст.

Давайте рассмотрим конкретный пример. Сделаем простой составной компонент `Toggle`, который будет управлять отображением/скрытием некоторого контента по клику. У нас будет `<Toggle>` контейнер и дочерние компоненты `<Toggle.On>`, `<Toggle.Off>` и `<Toggle.Button>`. 

```jsx
const ToggleContext = React.createContext();

function Toggle({ children }) {
  const [on, setOn] = React.useState(false);
  const toggle = () => setOn(prev => !prev);
  return (
    <ToggleContext.Provider value={{ on, toggle }}>
      {children}
    </ToggleContext.Provider>
  );
}

function ToggleOn({ children }) {
  const { on } = React.useContext(ToggleContext);
  return on ? <>{children}</> : null;
}

function ToggleOff({ children }) {
  const { on } = React.useContext(ToggleContext);
  return on ? null : <>{children}</>;
}

function ToggleButton({ children }) {
  const { toggle } = React.useContext(ToggleContext);
  return <button onClick={toggle}>{children}</button>;
}

// Использование:
<Toggle>
  <ToggleOn>Секретное сообщение видно!</ToggleOn>
  <ToggleOff>Секретное сообщение скрыто.</ToggleOff>
  <ToggleButton>Переключить</ToggleButton>
</Toggle>
```

Здесь `<Toggle>` управляет состоянием `on` (показано/скрыто) и предоставляет через контекст значение `{ on, toggle }` всем потомкам. `<ToggleOn>` и `<ToggleOff>` читают `on` и в зависимости от него либо рендерят `children`, либо нет. `<ToggleButton>` получает из контекста функцию `toggle` и вызывает её при клике. В итоге снаружи мы получаем удобный декларативный интерфейс: внутрь `<Toggle>` мы поместили разные части UI, которые сами знают, когда им отображаться и что делать при клике – мы лишь описали структуру, не связывая их вручную пропсами.

Обратите внимание: компоненту `<Toggle>` все равно, сколько у него внутри `<ToggleOn>` или `<ToggleOff>`, и что внутри них за JSX. Он также не привязан к конкретной разметке кнопки – мы сами передали кнопку с нужным текстом. Всё завязано только на контекстное состояние. Это и есть сила композиции: пользователю библиотеки даются "кирпичики" (несколько компонентов), из которых он может сложить нужную конструкцию по своему вкусу, а не один монолитный компонент с десятком пропсов-настроек.

Плюсы этого паттерна: огромная гибкость и выразительность. Хороший compound-компонент ощущается как маленький фреймворк. Например, библиотека @reach/ui (предшественник современной radix-ui) много компонентов строила через такой паттерн: диалоги, списки, выпадающие меню – всё через контекст и вложенные компоненты. Пользователю легко понять API – просто вложи одни компоненты в другие. Появляется возможность тонко настроить выходной HTML, вставить дополнительные элементы, если надо (ведь внутри `children` вы не ограничены – можно обернуть тот же `<ToggleButton>` в какой-нибудь `<div>` с нужным классом). Проще поддерживать визуальное единообразие: все части контролируются одним контекстом, не размазывая логику по нескольким несвязанным компонентам.

Минусы: сложнее реализовать. Нужно аккуратно продумать взаимодействие компонентов, предусмотреть, что некоторые могут отсутствовать или повторяться. Если неправильно спроектировать, можно столкнуться с багами: например, если `<ToggleButton>` случайно использовать вне `<Toggle>` (то есть вне провайдера), `useContext` вернёт `undefined` и будет ошибка – надо либо избегать такого, либо делать проверки и бросать понятное сообщение об ошибке (мол, "ToggleButton должен быть потомком Toggle").

Ещё момент – производительность: когда контекстное значение меняется, все потребители контекста обновятся. Например, при каждом клике `toggle` выше перемонтируются и `<ToggleOn>`, и `<ToggleOff>`, и `<ToggleButton>`. В данном случае это пустяки, но если бы у нас был десяток сложных детей на контексте, и состояние менялось часто, нужно было бы подумать об оптимизации (разбивке контекстов или мемоизации).

Тем не менее, плюсы обычно перевешивают: паттерн Compound Components позволяет создать очень понятный и гибкий пользовательский API для ваших компонентов. Это проявление философии React – композиция важнее наследования. Вместо того чтобы делать сложный компонент с кучей условий или наследников, мы делаем набор простых компонентов, которые в комбинации дают сложное поведение.

Compound Components – довольно "профессиональный" паттерн. В небольших приложениях вы можете не столкнуться с необходимостью его реализовывать, но если разрабатываете библиотеку компонентов или сложный виджет, такой подход становится золотым стандартом. Практически все продвинутые React UI-библиотеки (Material UI, Chakra, Radix и т.д.) используют контекст и композицию под капотом для своих сложных компонентов.

## 7. Серверные компоненты и Suspense: современные возможности React

Наконец, поговорим о новейших возможностях, которые принесли React 18 и грядущий React 19. Они направлены на улучшение работы с асинхронностью, данными и рендерингом на стороне сервера. В первую очередь это React Suspense и Server Components. Эти вещи ещё не до конца устоялись, но опытным React-разработчикам уже стоит их держать в уме.

### Suspense – ожидание с комфортом

Когда интерфейсу нужно загрузить данные или код, всегда встаёт задача: показать индикатор загрузки, пока всё не готово. Раньше приходилось вручную писать логику: например, состояние `isLoading` и условный рендер то спиннера, то контента. С появлением React Suspense предложен более декларативный способ. Suspense – это специальный компонент, который позволяет приостановить рендеринг своих дочерних компонентов, пока те не готовы, и показать запасной UI (fallback) в это время.

Проще говоря, мы оборачиваем часть дерева компонентов в `<Suspense fallback={<Loader/>}> ... </Suspense>`, и если внутри этой области происходит задержка (например, идёт загрузка кода или данных), React автоматически покажет `<Loader>` вместо содержимого, а когда всё завершится – отобразит сами компоненты. Suspense берёт на себя координацию этого процесса, освобождая нас от ручного управления состоянием загрузки.

На сегодня Suspense широко используется для ленивой загрузки компонентов (`React.lazy` + `<Suspense>`). Пример:

```jsx
const Comments = React.lazy(() => import('./Comments'));

function ArticlePage() {
  return (
    <div>
      {/* ... содержимое статьи ... */}
      <Suspense fallback={<div>Комментарии загружаются...</div>}>
        <Comments postId={42} />
      </Suspense>
    </div>
  );
}
```

Здесь компонент `Comments` будет подгружён по требованию (в отдельном бандле). Пока бандл не загрузится, пользователь увидит текст "Комментарии загружаются...". Как только код придет, React отрисует `<Comments>`. Всё это без какого-либо специального кода внутри `ArticlePage` для отслеживания загрузки – Suspense сам разрулит ситуацию: `React.lazy` под капотом бросает Promise на время загрузки, а `<Suspense>` ловит его и показывает фолбек.

Кроме ленивой загрузки кода, Suspense постепенно начинает применяться и для асинхронных данных. В React 18 появился экспериментальный API, позволяющий Suspense работать с данными – например, можно использовать специальный `use` для ожидания промиса прямо внутри компонента (пока официально не стабильно, но фреймворки типа Next.js 13 уже вовсю пользуются). Идея та же: компонент, который загружает данные, вместо того чтобы сразу вернуть JSX, может "suspend" – приостановить своё выполнение до получения данных. React, обнаружив это, покажет fallback, а когда данные придут – продолжит рендер компонента. Таким образом, можно писать компонент, который выглядит синхронным, хотя внутри у него асинхронный код – за счёт Suspense-а пользователю не показывается незавершённый результат.

Признаться, Suspense для данных – пока что область экспериментов и специфичных решений. Если вы пишете обычное приложение на CRA/Vite, без Next, то прямо сейчас воспользоваться Suspense для загрузки данных "из коробки" не выйдет – потребуется либо сторонняя библиотека (например, React Query пока не интегрирован с Suspense по умолчанию, но планирует), либо фреймворк. Однако направление понятное: React движется к тому, чтобы сделать работу с асинхронностью более декларативной. Уже сейчас вы можете использовать Suspense для спиннеров и заглушек при загрузке кода, а в ближайшем будущем, вероятно, подобный подход станет нормой и для данных (в React 19+ должны появиться официальные инструменты для этого).

Подводя итог по Suspense: этот паттерн позволяет очень элегантно организовать отображение загрузки. Вместо множества условных `isLoading ? ... : ...` мы просто заявляем: "Эта часть UI может задержаться, показывай пока вот это". Это улучшает UX (пользователь видит скелетон или лоадер без вспышек незагруженного контента) и упрощает код. Следите за развитием Suspense – возможно, скоро он будет использоваться намного шире, чем сейчас.

## Серверные компоненты – React выходит на сервер

Ещё одна революционная идея – React Server Components (RSC), или серверные компоненты. Это попытка объединить лучшее из мира серверного рендеринга и клиентских SPA. Смысл в том, что часть ваших React-компонентов может выполняться только на сервере, генерируя готовый HTML, который отправляется клиенту. Эти компоненты никогда не попадают в бандл JS, не несут в себе интерактива – они чисто для рендеринга контента. Другая часть компонентов остаётся "клиентской" – обычные React-компоненты, которые умеют обрабатывать события, иметь состояние и т.д. Разделение происходит явно: React различает, какой компонент предназначен для сервера, а какой для клиента.

Как React понимает, где выполнять компонент? Введена директива `"use client"`: если файл компонента начинается с этой строки, то компонент клиентский – он будет собран в JS и выполнится в браузере. Если такой строки нет – компонент считается серверным и по умолчанию выполняется на сервере (например, при рендеринге страницы на Node.js). Серверный компонент может содержать асинхронный код (запросы к БД, файловой системе и т.п.), ведь он запускается в среде сервера. Но он не может использовать, например, `useState` или `useEffect` – ведь у него нет постоянного состояния между запросами, да и доступ к DOM ему ни к чему.

React 18 (и в полной мере React 19) позволяют фреймворкам использовать эту возможность. Например, Next.js 13 с новым `app/` роутером делает все компоненты по умолчанию серверными, если не указать "use client". Таким образом, большую часть страницы вы можете рендерить на сервере, отдавая сразу готовый HTML, а для интерактивных элементов включать клиентские компоненты.

Преимущества Server Components: во-первых, производительность. Серверные компоненты избегают гидрации, клиенту не нужно повторно исполнять JS, чтобы восстановить состояние UI. Вы получаете выгоды SSR (быстрый первый рендер, минимум работы на клиенте) без обычных недостатков SSR (необходимость гидрации большого объёма HTML). Во-вторых, безопасность: чувствительный код остается на сервере, не попадая в бандл, и данные можно получать напрямую на сервере (например, напрямую из базы) без передачи ключей API в браузер. В-третьих, размер бандла существенно сокращается – клиент вообще не получает код серверных компонентов, только итоговый HTML и нужный JS для оставшихся интерактивных частей.

Как это выглядит на практике? Представим блог. Страницу поста можно сделать целиком серверным компонентом: он на сервере загрузит пост из БД и вернёт готовую верстку статьи. Комментарии под постом могут быть тоже сгенерированы сервером (если они не интерактивны). А кнопка "Лайк" или форма добавления комментария – это уже интерактив, их делаем клиентскими компонентами. В результате пользователь, заходя на страницу, сразу получает полностью готовую страницу с постом и комментариями (никакого спиннера, всё пререндерено). А JS-код загружается только для кнопки лайка и формы комментария, и только они гидрируются и начинают работать на клиенте. Это сочетание SSR и SPA, orchestrated by React.

React строго определяет, как серверные и клиентские компоненты могут взаимодействовать. Серверный компонент может импортировать и использовать другой серверный или клиентский компонент, а вот клиентский компонент не может импортировать серверный. То есть дерево может быть: Серверный -> внутри него Клиентский -> внутри него ещё Клиентский и т.д. Но не наоборот. В примере выше, серверный компонент страницы может рендерить внутри себя `<LikeButton />` (клиентский компонент кнопки). А если бы вы попробовали внутри клиентского компонента сделать `import PostDetails from './PostDetails.server.jsx'` – сборка не позволит, скажет, что нельзя так. Таким образом, архитектура разделяется: "верхние" уровни страницы – серверные, "листья" интерактивности – клиентские.

Server Components – это пока прерогатива фреймворков. То есть в обычном CRA-приложении вы вручную не сможете этим воспользоваться без большого труда. Но если вы работаете с Next.js, Remix, или в целом full-stack React-приложениями, то RSC уже доступны. В React 19 они обещают быть полностью стабильными (в React 18 это скорее эксперимент для энтузиастов). Библиотеки тоже начинают подстраиваться: например, React Router v7 планирует поддерживать RSC, Vite тоже экспериментирует с этим.

Отдельно стоит упомянуть Server Actions – это связанная новая возможность (React 18/19). Server Actions позволяют вызывать функции на сервере прямо из клиентского компонента, минуя привычные REST/GraphQL. Например, можно написать функцию `async function addComment(data) { "use server"; ... }` и вызывать её в клиентском компоненте `<form onSubmit={addComment}>`. React увидит, что это серверное действие (`"use server"`), и при вызове отправит данные на сервер, выполнит функцию и вернёт результат. Всё прозрачно, не нужно писать отдельный API-эндпойнт. Server Actions хорошо сочетаются с RSC, позволяя организовать полный цикл: серверные компоненты отображают данные, а Server Actions обновляют эти данные по запросу с клиента. Пока это тоже новинка и работает в ограниченном числе сред (в Next.js 13, например, уже можно пользоваться).

Что в итоге дают серверные компоненты? Потенциально, большой скачок в производительности и удобстве разработки full-stack приложений. Мы получаем паттерн разделения по среде: какие компоненты должны рендериться на сервере, а какие – на клиенте. Это новое измерение при проектировании React-приложения. Опытному разработчику теперь нужно не только думать о разделении логики/UI или о повторном использовании, но и решать, где лучше выполнить тот или иной код – на сервере или в браузере. Правильное использование RSC может значительно ускорить приложение без лишних усилий для разработчика (React сам разруливает, когда и что подгружать, синхронизирует состояние между сервером и клиентом).

С другой стороны, появляется дополнительная сложность в понимании: нужно чётко осознавать ограничения (например, нельзя в серверном компоненте использовать `useEffect`, или что состояние в серверном компоненте не сохраняется между запросами). Но это всё решаемо практикой и хорошей документацией.

На момент написания (начало 2025 года) паттерн Server Components ещё набирает популярность. Возможно, через год-другой он станет таким же обычным делом, как сейчас хуки.

## Заключение

Мы рассмотрели пять ключевых паттернов React и даже заглянули в будущее React-архитектур. Контейнеры и презентационные компоненты привносят порядок, отделяя логику от отображения. HOC и Render Props – старые приёмы для повторного использования кода, которые в значительной мере вытеснены более современными хуками, но по-прежнему встречаются в проектах. Контекст позволяет избавляться от избыточной передачи пропсов и делиться состоянием между компонентами. Compound Components демонстрируют силу композиции, давая API для гибкой сборки компонентов из небольших частей. А Suspense и Server Components – это уже новые горизонты, делающие работу с асинхронностью и рендерингом более эффективной и декларативной.

Важно понимать, что паттерны – не догмы. В каждом конкретном приложении их нужно применять с умом. Порой проще обойтись без паттерна, чем усложнять архитектуру ради "красивого" решения. Однако знание этих подходов обогащает ваш инструментарий. Когда вы сталкиваетесь с определённой проблемой, на подкорке всплывает: ага, здесь бы подошёл такой-то паттерн! Опытный разработчик видит несколько вариантов реализации и выбирает оптимальный.

От себя добавлю: изучая паттерны, всегда пробуйте их в деле. Напишите свой HOC, переделайте компонент с Render Props на хук, реализуйте небольшой набор Compound Components – так вы прочувствуете их сильные и слабые стороны. React развивается, и появляются новые приёмы, но фундаментальные идеи (композиция, разделение обязанностей, явное управление состоянием) остаются. Владейте этими инструментами – и ваши React-приложения будут благодарить вас чистотой и поддерживаемостью кода!

