# Глубокое понимание useMemo, useCallback и React.memo в React: когда их стоит использовать

## Введение

Оптимизация производительности React-приложений — важный аспект разработки, особенно когда речь идет о сложных и ресурсоемких интерфейсах. Часто разработчики слышат о необходимости использовать хуки useMemo, useCallback и функцию React.memo для повышения эффективности их кода. Однако бездумное использование этих инструментов способно навредить вашему приложению.

В этой статье мы разберем, когда действительно стоит использовать эти инструменты, а когда они излишни. Мы рассмотрим особенности каждого из хуков, их влияние на рендеринг компонентов в React, а также проанализируем практические примеры с подробными объяснениями.

## Краткое описание хуков

### React.memo

React.memo — это функция высшего порядка, которая предотвращает ненужные повторные рендеры функционального компонента, если его пропсы не изменились. Она работает путем поверхностного сравнения текущих и предыдущих пропсов компонента.

**Важно отметить:**

- Если пропсы являются объектами или функциями, они могут каждый раз создаваться заново при рендеринге, даже если их значения не изменились. Это может привести к тому, что React.memo не сможет определить, что пропсы остались прежними, и компонент будет перерисован.
- Чтобы избежать этого, необходимо обеспечить стабильность таких пропсов с помощью useMemo и useCallback.

### useCallback

useCallback возвращает мемоизированную версию функции, которая сохраняется между рендерами, пока зависимости не изменяются. Это полезно при передаче колбэков в оптимизированные компоненты, зависящие от ссылочного равенства.

**Особенности:**

- Позволяет избежать создания новых функций при каждом рендере.
- Требует указания массива зависимостей, изменения в которых обновят функцию.
- Необходимо следить за массивом зависимостей, чтобы избежать проблем с устаревшими замыканиями (stale closure).

### useMemo

useMemo мемоизирует результат вычисления и пересчитывает его только тогда, когда изменяются указанные зависимости. Это полезно для оптимизации тяжелых вычислений.

**Особенности:**

- Избегает повторных вычислений при каждом рендере.
- Требует точного указания зависимостей.
- Может привести к проблемам с устаревшими данными, если зависимости указаны неверно.

## Вопрос к читателю

Как вы думаете, улучшит ли производительность оборачивание increment в useCallback и Button в React.memo в следующем примере? Какой из следующих вариантов будет более эффективным с точки зрения производительности кода?

1. Использовать useCallback для increment и обернуть Button в React.memo.
2. Оставить код без изменений.

**Подумайте над ответом, прежде чем читать дальше.**

## Особенности рендеринга и хуков в React

Прежде чем ответить на вопрос, рассмотрим некоторые особенности рендеринга в React и работы хуков.

### Создание функций при каждом рендере

В функциональных компонентах каждая функция, объявленная внутри компонента, создается заново при каждом рендере. Это означает, что:

- Функция increment в компоненте Counter создается заново при каждом обновлении состояния.
- При передаче этой функции в дочерний компонент она будет иметь новое значение ссылки, даже если логика внутри не изменилась.

### Влияние на дочерние компоненты

- Если дочерний компонент зависит от ссылочного равенства пропсов (например, обернут в React.memo), то изменение ссылки на функцию приведет к его повторному рендеру.
- В случае простых компонентов это может быть незначительным, но в сложных компонентах это может повлиять на производительность.

### Массив зависимостей и stale closure

- При использовании useCallback и useMemo важно правильно указывать массив зависимостей.
- Неправильное указание или пропуск зависимостей может привести к тому, что функция или вычисление будут использовать устаревшие значения из замыкания (stale closure).

## Анализ и объяснение

### Вариант с useCallback и React.memo

```jsx
const Button = React.memo(function Button({ onClick, label }) {
  console.log(`Рендер кнопки: ${label}`);
  return <button onClick={onClick}>{label}</button>;
});

function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = React.useCallback(() => setCount((c) => c + 1), []);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <Button onClick={increment} label="Увеличить" />
    </div>
  );
}
```

### Вариант без оптимизации

```jsx
function Button({ onClick, label }) {
  console.log(`Рендер кнопки: ${label}`);
  return <button onClick={onClick}>{label}</button>;
}

function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = () => setCount((c) => c + 1);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <Button onClick={increment} label="Увеличить" />
    </div>
  );
}
```

### Ответ

На первый взгляд, использование useCallback и React.memo должно улучшить производительность, предотвращая ненужные перерисовки Button. Однако в данном примере выигрыш будет минимальным, либо, что вероятнее, отсутствовать вовсе.

### Почему?

- **Создание функций в рендере:** В обоих вариантах функция increment создается при каждом рендере. Однако с useCallback мы мемоизируем функцию, предотвращая ее пересоздание, если зависимости не изменились.
- **Дополнительные затраты:** Использование useCallback и React.memo требует ресурсов для отслеживания зависимостей и сравнения пропсов. Это добавляет небольшую нагрузку.
- **Сложность компонента:** Компонент Button простой и его рендеринг занимает минимальное время. Оптимизация в этом случае не даст заметного эффекта.
- **Учет массива зависимостей:** В useCallback мы указали пустой массив зависимостей. Если бы внутри increment использовались переменные из внешнего окружения, нужно было бы добавить их в зависимости, чтобы избежать устаревшего замыкания.

**Вывод:** В данном случае использование useCallback и React.memo не улучшит производительность (возможно даже ухудшит из-за дополнительных затрат) и усложнит код.

## Оптимизация с ресурсоемкими вычислениями

Теперь рассмотрим пример, где оптимизация действительно имеет смысл.

### Без useMemo

```jsx
function HeavyComputation({ num }) {
  const compute = (n) => {
    // Имитация тяжелых вычислений
    let result = 0;
    for (let i = 0; i < 1e7; i++) {
      result += n * Math.random();
    }
    return result;
  };

  const value = compute(num);

  return <div>Результат вычислений: {value}</div>;
}

function App() {
  const [number, setNumber] = React.useState(42);
  const [toggle, setToggle] = React.useState(false);

  return (
    <div>
      <button onClick={() => setToggle((t) => !t)}>Переключить</button>
      <HeavyComputation num={number} />
    </div>
  );
}
```

Каждый раз при нажатии на кнопку "Переключить" компонент HeavyComputation выполняет тяжелые вычисления, хотя num не меняется.

### С использованием useMemo

```jsx
function HeavyComputation({ num }) {
  const compute = (n) => {
    let result = 0;
    for (let i = 0; i < 1e7; i++) {
      result += n * Math.random();
    }
    return result;
  };

  const value = React.useMemo(() => compute(num), [num]);

  return <div>Результат вычислений: {value}</div>;
}
```

Теперь compute(num) будет вызываться только тогда, когда num изменяется.

**Вывод:** Использование useMemo в данном случае оправдано, так как оно предотвращает ненужные тяжелые вычисления при каждом рендере.

## Смысл оптимизации

**Главная мысль:** Оптимизации не бесплатны. Каждая оптимизация добавляет сложность и требует ресурсов. Важно оценивать, приносит ли она реальную пользу.

- **Память и производительность:** Мемоизация использует дополнительную память для хранения результатов и отслеживания зависимостей.
- **Сложность кода:** Избыточное использование оптимизаций усложняет код и делает его менее читаемым.
- **Необходимость измерения:** Оптимизируйте только после того, как убедитесь в наличии проблемы, используя инструменты профилирования.
- **Массив зависимостей и устаревшие замыкания:** Неправильное указание зависимостей может привести к багам из-за использования устаревших данных. Всегда следите за тем, чтобы массив зависимостей был актуален.

## Когда действительно стоит использовать useCallback и useMemo

### 1. Ссылочное равенство (Referential Equality)

Если вы передаете функции или объекты в качестве пропсов в дочерние компоненты, обернутые в React.memo, и эти компоненты зависят от ссылочного равенства пропсов для предотвращения перерисовок.

**Пример:**

```jsx
const Child = React.memo(function Child({ onAction }) {
  // ... сложный и ресурсоемкий компонент Child
});

function Parent() {
  const [value, setValue] = React.useState(0);

  const handleAction = React.useCallback(() => {
    // Используем value в функции
    console.log(value);
  }, [value]); // Не забудьте указать value в зависимостях

  return <Child onAction={handleAction} />;
}
```

**Обратите внимание:**

- Здесь handleAction использует value из состояния. Поэтому мы добавили value в массив зависимостей useCallback. Это предотвращает проблему устаревшего замыкания.
- Если бы мы не добавили value в зависимости, handleAction всегда использовал бы значение value, которое было при первом рендере.

### 2. Ресурсоемкие вычисления (Computationally Expensive Calculations)

Когда вычисление значения требует значительных ресурсов, и вы хотите избежать повторных вычислений при каждом рендере.

**Пример:**

```jsx
function ExpensiveComponent({ data }) {
  const processedData = React.useMemo(() => heavyCompute(data), [data]);

  return <Display data={processedData} />;
}
```

**Обратите внимание:**

- heavyCompute(data) выполняется только тогда, когда data изменяется.
- Это существенно повышает производительность, если heavyCompute — действительно тяжелая функция.

## Минусы использования хуков с массивом зависимостей

- **Необходимость следить за массивом зависимостей:** Пропуск зависимостей или их неправильное указание может привести к багам из-за устаревших данных.
- **Устаревшее замыкание (Stale Closure):** Функции и значения могут "застрять" в замыкании, если зависимости не обновляются.
- **Сложность в поддержке:** Добавление хуков с зависимостями требует внимательности и может усложнить кодовую базу.

**Рекомендации:**

- Всегда проверяйте массив зависимостей и обновляйте его при необходимости.
- Используйте линтеры, такие как eslint-plugin-react-hooks, чтобы автоматически выявлять проблемы с зависимостями.
- Понимайте, как работают замыкания в JavaScript, чтобы избежать неожиданных поведений.

## Заключение

**Оптимизируйте осознанно.**

- **Не оптимизируйте преждевременно:** Сначала убедитесь, что есть проблема.
- **Используйте инструменты профилирования:** Они помогут выявить реальные узкие места.
- **Понимайте стоимость оптимизации:** Каждая оптимизация имеет свою цену в виде сложности кода и использования ресурсов.
- **Следите за развитием React:** В 19 версии React разработчики показали нам компайлер, который сам, под капотом занимается большей частью оптимизации

**Помните:** Главная цель — писать чистый, понятный и эффективный код. Оптимизации должны служить этой цели, а не препятствовать ей.
