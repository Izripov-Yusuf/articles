# Глубокое понимание useMemo, useCallback и React.memo в React: когда их стоит использовать

## Введение

Оптимизация производительности React-приложений — важный аспект разработки, особенно когда речь идет о сложных и ресурсоемких интерфейсах. Часто разработчики слышат о необходимости использовать хуки useMemo, useCallback и функцию React.memo для повышения эффективности их кода. Однако бездумное использование этих инструментов способно навредить вашему приложению.

В этой статье мы разберем, когда действительно стоит использовать эти инструменты, а когда они излишни. Мы рассмотрим практические примеры, проведем анализ и дадим рекомендации на основе реального опыта.

## Пример без оптимизации

Рассмотрим простой компонент счетчика (это максимально простой пример, но я встречал +- подобные примеры в реальной разработке)

```jsx
function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <button onClick={increment}>Увеличить</button>
    </div>
  );
}
```

Этот компонент работает корректно: при нажатии на кнопку значение счетчика увеличивается на единицу.
Теперь представим, что у нас есть дочерний компонент, который принимает обработчик события:

```jsx
function Button({ onClick, label }) {
  console.log(`Рендер кнопки: ${label}`);
  return <button onClick={onClick}>{label}</button>;
}

function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <Button onClick={increment} label="Увеличить" />
    </div>
  );
}
```

## Вопрос к читателю

Как вы думаете, улучшит ли производительность оборачивание increment в useCallback и Button в React.memo? Какой из следующих вариантов будет более эффективным с точки зренеия производительности кода?

1. Использовать useCallback для increment и обернуть Button в React.memo.
2. Оставить код без изменений.

## Подумайте над ответом, прежде чем читать дальше.

## Анализ и объяснение

Вариант с useCallback и React.memo:

```jsx
const Button = React.memo(function Button({ onClick, label }) {
  console.log(`Рендер кнопки: ${label}`);
  return <button onClick={onClick}>{label}</button>;
});

function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = React.useCallback(() => setCount((c) => c + 1), []);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <Button onClick={increment} label="Увеличить" />
    </div>
  );
}
```

Вариант без оптимизации:

```jsx
function Button({ onClick, label }) {
  console.log(`Рендер кнопки: ${label}`);
  return <button onClick={onClick}>{label}</button>;
}

function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = () => setCount((c) => c + 1);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <Button onClick={increment} label="Увеличить" />
    </div>
  );
}
```

## Ответ:

На первый взгляд, использование useCallback и React.memo должно улучшить производительность, предотвращая ненужные перерисовки Button. Однако в данном примере выигрыш будет минимальным, либо, что вероятнее, отсутствовать вовсе.

## Почему?

- **Создание функций в рендере:** В обоих вариантах функция increment создается при каждом рендере. Однако в случае с useCallback мы добавляем дополнительную работу по мемоизации функции.
- **Дополнительная нагрузка:** Использование useCallback и React.memo требует ресурсов для отслеживания зависимостей и сравнения пропсов
- **Реальная производительность:** Для такого простого компонента, как Button, время рендеринга незначительно, и оптимизация не даст заметного эффекта.

Вывод: В данном случае использование useCallback и React.memo не улучшит производительность (возможно даже ухудшит, нужно замерить) и усложнит код.

## Оптимизация с ресурсоемкими вычислениями

Теперь рассмотрим пример, где оптимизация действительно имеет смысл.

Без useMemo:

```jsx
function HeavyComputation({ num }) {
  const compute = (n) => {
    // Имитация тяжелых вычислений
    let result = 0;
    for (let i = 0; i < 1e7; i++) {
      result += n * Math.random();
    }
    return result;
  };

  const value = compute(num);

  return <div>Результат вычислений: {value}</div>;
}

function App() {
  const [number, setNumber] = React.useState(42);
  const [toggle, setToggle] = React.useState(false);

  return (
    <div>
      <button onClick={() => setToggle((t) => !t)}>Переключить</button>
      <HeavyComputation num={number} />
    </div>
  );
}
```

Каждый раз при нажатии на кнопку "Переключить" компонент HeavyComputation выполняет тяжелые вычисления, хотя num не меняется.

С использованием useMemo:

```jsx
function HeavyComputation({ num }) {
  const compute = (n) => {
    let result = 0;
    for (let i = 0; i < 1e7; i++) {
      result += n * Math.random();
    }
    return result;
  };

  const value = React.useMemo(() => compute(num), [num]);

  return <div>Результат вычислений: {value}</div>;
}
```

Теперь compute(num) будет вызываться только тогда, когда num изменяется.

**Вывод:** Использование useMemo в данном случае оправдано, так как оно предотвращает ненужные тяжелые вычисления при каждом рендере.

## Смысл оптимизации

**Главная мысль:** Оптимизации не бесплатны. Каждая оптимизация добавляет сложность и требует ресурсов. Важно оценивать, приносит ли она реальную пользу.

- **Память и производительность:** Мемоизация использует дополнительную память для хранения результатов и отслеживания зависимостей.
- **Сложность кода:** Избыточное использование оптимизаций усложняет код и делает его менее читаемым.
- **Необходимость измерения:** Оптимизируйте только после того, как убедитесь в наличии проблемы, используя инструменты профилирования.

## Когда действительно стоит использовать useCallback и useMemo

1. **Ссылочное равенство (Referential Equality):**
   Если вы передаете функции или объекты в качестве пропсов в дочерние компоненты, обернутые в React.memo, и эти компоненты зависят от ссылочного равенства пропсов для предотвращения перерисовок.

**Пример:**

```jsx
const Child = React.memo(function Child({ onAction }) {
  // ... сложный и ресурсоемкий компонент Child
});

function Parent() {
  const handleAction = React.useCallback(() => {
    // ... компонент Parent
  }, []);

  return <Child onAction={handleAction} />;
}
```

2. **Ресурсоемкие вычисления (Computationally Expensive Calculations):**
   Когда вычисление значения требует значительных ресурсов, и вы хотите избежать повторных вычислений при каждом рендере.

**Пример:**

```jsx
function ExpensiveComponent({ data }) {
  const processedData = React.useMemo(() => heavyCompute(data), [data]);

  return <Display data={processedData} />;
}
```

## Понимание React.memo и его особенностей

React.memo — это функция высшего порядка, которая предотвращает ненужные повторные рендеры функционального компонента, если его пропсы не изменились. Она работает путем сравнения текущих и предыдущих пропсов компонента с помощью поверхностного сравнения.

**Важно отметить:**

- Если вы передаете в пропсы компонента объекты, массивы или функции, они могут каждый раз создаваться заново при рендеринге, даже если их значения не изменились. Это приведет к тому, что React.memo не сможет определить, что пропсы остались прежними, и компонент будет перерисован.
- Чтобы обеспечить стабильность таких пропсов и избежать ненужных рендеров, используйте useMemo для мемоизации объектов и массивов, и useCallback для мемоизации функций.
- Чрезмерное использование React.memo может усложнить код и добавить дополнительную нагрузку на сравнение пропсов, без существенной выгоды для производительности.

Таким образом, React.memo полезен в случаях, когда ваш компонент рендеринг занимает значительное время, и вы хотите избежать его повторной отрисовки без необходимости.

## Заключение

**Оптимизируйте осознанно.**

- **Не оптимизируйте преждевременно:** Сначала убедитесь, что есть проблема.
- **Используйте инструменты профилирования:** Они помогут выявить реальные узкие места
- **Понимайте стоимость оптимизации:** Каждая оптимизация имеет свою цену в виде сложности кода и использования ресурсов.
- **Следите за развитием React:** В 19 версии React разработчики показали нам компайлер, который сам, под капотом занимается большей частью оптимизации
