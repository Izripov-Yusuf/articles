# Глубокое понимание useMemo, useCallback и React.memo в React: когда их стоит использовать

## Введение

Оптимизация производительности React-приложений — важный аспект разработки, особенно когда речь идет о сложных и ресурсоемких интерфейсах. Часто разработчики слышат о необходимости использовать хуки useMemo, useCallback и функцию React.memo для повышения эффективности их кода. Однако бездумное использование этих инструментов способно навредить вашему приложению.

В этой статье мы разберем, когда действительно стоит использовать эти инструменты, а когда они излишни. Мы рассмотрим особенности каждого из хуков, их влияние на рендеринг компонентов в React, а также проанализируем практические примеры с подробными объяснениями.

## Особенности рендеринга в React

Прежде чем углубиться в детали, важно понять, как работает рендеринг в React.

- **Компонент как функция:** В функциональном компоненте тело функции выполняется при каждом рендере. Это означает, что все переменные и функции, объявленные внутри компонента, будут пересоздаваться при каждом рендере.
- **Пересоздание функций и объектов:** Каждая функция и объект, созданные внутри компонента, будут новыми при каждом рендере. Однако хуки, такие как useState и useEffect, сохраняют своё состояние между рендерами благодаря внутренним механизмам React.

## Краткое описание хуков

### React.memo

React.memo — это **компонент высшего порядка (Higher Order Component, HOC)**, который мемоизирует результат рендера функционального компонента. Если пропсы компонента не изменились, React повторно использует результат предыдущего рендера, избегая ненужной перерисовки.

**Особенности:**

- **Поверхностное сравнение (shallow equal):** React.memo сравнивает текущие и предыдущие пропсы с помощью Object.is, сравнивая их по ссылке.
- **Эффективен с пропсами примитивами:** Лучше всего работает, когда пропсы — примитивные типы (числа, строки, булевы значения).
- **Неэффективен с сложными объектами:** Если пропсы — объекты или функции, необходимо дополнительно использовать useMemo или useCallback для мемоизации этих пропсов.

### Примеры использования React.memo:

## Пример 1: Компонент с пропсами примитивами без React.memo

```jsx
function Display({ value }) {
  console.log('Рендер Display');
  return <div>{value}</div>;
}

function App() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <Display value="Статичный текст" />
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
    </div>
  );
}
```

**Что происходит:** При каждом нажатии на кнопку Display перерисовывается, хотя его пропс value не изменился. Это происходит потому, что родительский компонент App рендерится снова, и его дочерние компоненты также рендерятся.

## Пример 2: Компонент с примитивными пропсами, обёрнутый в React.memo

```jsx
const Display = React.memo(function Display({ value }) {
  console.log('Рендер Display');
  return <div>{value}</div>;
});

function App() {
  const [count, setCount] = React.useState(0);

  return (
    <div>
      <Display value="Статичный текст" />
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
    </div>
  );
}
```

**Что происходит:** Теперь Display не перерисовывается при изменении состояния App, так как его пропс value не изменился, и благодаря React.memo он избегает ненужного рендеринга.

## Пример 3: Компонент с непримитивными пропсами, обёрнутый в React.memo

```jsx
const Display = React.memo(function Display({ data }) {
  console.log('Рендер Display');
  return <div>{data.value}</div>;
});

function App() {
  const [count, setCount] = React.useState(0);
  const data = { value: 'Статичный текст' };

  return (
    <div>
      <Display data={data} />
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
    </div>
  );
}
```

**Наблюдение:** Несмотря на то, что data.value не изменяется, Display перерисовывается при каждом рендере App, потому что объект data пересоздаётся при каждом рендере, и его ссылка меняется. React.memo видит, что проп data изменился (ссылочно), и перерисовывает компонент.

**Как исправить:**

Использовать useMemo для мемоизации объекта data:

```jsx
const Display = React.memo(function Display({ data }) {
  console.log('Рендер Display');
  return <div>{data.value}</div>;
});

function App() {
  const [count, setCount] = React.useState(0);
  const data = React.useMemo(() => ({ value: 'Статичный текст' }), []);

  return (
    <div>
      <Display data={data} />
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
    </div>
  );
}
```

Теперь data будет иметь стабильную ссылку между рендерами, и Display не будет перерисовываться без необходимости.

### useCallback

useCallback возвращает мемоизированную версию функции, которая сохраняется между рендерами до тех пор, пока не изменятся указанные зависимости.

### Пример использования useCallback:

```jsx
const Button = React.memo(function Button({ onClick, label }) {
  console.log(`Рендер кнопки: ${label}`);
  return <button onClick={onClick}>{label}</button>;
});

function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = React.useCallback(() => setCount((c) => c + 1), []);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <Button onClick={increment} label="Увеличить" />
    </div>
  );
}
```

### Объяснение:

- increment мемоизирован с помощью useCallback, и его ссылка остаётся стабильной между рендерами, пока зависимости не изменяются.
- Button обёрнут в React.memo, поэтому он не будет перерисовываться, если его пропсы не изменятся.
- В данном случае, если increment не использует переменных из внешнего окружения (или они не изменяются), его ссылка останется стабильной.

### Важные моменты:

- **Следить за массивом зависимостей, чтобы избежать проблем с устаревшими замыканиями (stale closure).**
- **Функция всё ещё создаётся:** Несмотря на то, что ссылка остаётся стабильной, функция increment пересоздаётся при каждом рендере, но useCallback возвращает предыдущую версию, если зависимости не изменились.

## Проблема с устаревшим замыканием

```jsx
function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = React.useCallback(() => setCount(count + 1), []);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <button onClick={increment}>Увеличить</button>
    </div>
  );
}
```

**Проблема:**

- Здесь count не указан в зависимостях useCallback.
- В результате, increment всегда будет использовать значение count, которое было при первом рендере.
- Это приведёт к тому, что счётчик не будет увеличиваться корректно.

**Решение:**

- Добавить count в зависимости:

```jsx
const increment = React.useCallback(() => setCount(count + 1), [count]);
```

### useMemo

useMemo мемоизирует результат функции и пересчитывает его только тогда, когда изменяются указанные зависимости.

### Пример использования useMemo

```jsx
function HeavyComputation({ num }) {
  const compute = (n) => {
    // Имитация тяжелых вычислений
    let result = 0;
    for (let i = 0; i < 1e7; i++) {
      result += n * Math.random();
    }
    return result;
  };

  const value = React.useMemo(() => compute(num), [num]);

  return <div>Результат вычислений: {value}</div>;
}

function App() {
  const [number, setNumber] = React.useState(42);
  const [toggle, setToggle] = React.useState(false);

  return (
    <div>
      <button onClick={() => setToggle((t) => !t)}>Переключить</button>
      <HeavyComputation num={number} />
    </div>
  );
}
```

**Объяснение:**

- compute(num) выполняется только тогда, когда num изменяется.
- Это предотвращает ненужные тяжелые вычисления при каждом рендере App.

### Мемоизация объектов и массивов

```jsx
function App() {
  const [count, setCount] = React.useState(0);

  const data = React.useMemo(() => ({ value: 'Статичный текст' }), []);

  return (
    <div>
      <Display data={data} />
      <button onClick={() => setCount(count + 1)}>Увеличить</button>
    </div>
  );
}
```

- Теперь data имеет стабильную ссылку между рендерами, и компоненты, зависящие от него, не будут перерисовываться без необходимости.

**Особенности:**

- **Избежание повторных вычислений:** Позволяет избежать выполнения тяжелых вычислений при каждом рендере.
- **Мемоизация объектов и массивов:** Помогает сохранить стабильность ссылок на объекты и массивы между рендерами.
- **Требует указания массива зависимостей, изменения в которых обновят значение.**
- **Необходимо следить за массивом зависимостей, чтобы избежать проблем с устаревшими замыканиями (stale closure).**

## Вопрос к читателю

Рассмотрим следующий пример:

```jsx
function Button({ onClick, label }) {
  console.log(`Рендер кнопки: ${label}`);
  return <button onClick={onClick}>{label}</button>;
}

function Counter() {
  const [count, setCount] = React.useState(0);

  const increment = () => setCount(count + 1);

  return (
    <div>
      <h1>Счетчик: {count}</h1>
      <Button onClick={increment} label="Увеличить" />
    </div>
  );
}
```

Каждый раз при рендере Counter создаётся новая функция increment, и Button получает новый проп onClick.

**Вопрос:** Улучшит ли производительность оборачивание increment в useCallback и Button в React.memo? Какой из следующих вариантов будет более эффективным с точки зрения производительности?

1. Использовать useCallback для increment и обернуть Button в React.memo.
2. Оставить код без изменений.

**Подумайте над ответом, прежде чем читать дальше.**

## Анализ и объяснение

### Создание функций при каждом рендере

- В функциональных компонентах все функции и объекты, объявленные внутри компонента, пересоздаются при каждом рендере.
- Это означает, что ссылки на эти функции и объекты меняются при каждом рендере, даже если их содержимое остаётся прежним.

## Влияние на дочерние компоненты

- Если дочерний компонент получает функцию или объект в качестве пропса и обёрнут в React.memo, изменение ссылки приведёт к его перерисовке.
- Это может вызвать ненужные перерисовки, если функции или объекты не мемоизированы.

### Ответ

На первый взгляд, оборачивание increment в useCallback и Button в React.memo должно предотвратить ненужные перерисовки Button. Однако в данном случае выигрыш в производительности будет незначительным или отсутствовать вовсе.

## Почему?

- **Простота компонента:** Компонент Button очень простой, и время его рендеринга минимально. Оптимизация в этом случае не даст заметного эффекта.
- **Дополнительные затраты на мемоизацию:** Использование useCallback и React.memo добавляет дополнительные затраты на мемоизацию и сравнение пропсов.
- **Следить за зависимостями:** В useCallback необходимо правильно указывать зависимости, чтобы избежать проблем с устаревшими данными.

**Вывод:** В данном случае оборачивание increment в useCallback и использование React.memo для Button не приведет к значимому улучшению производительности и усложнит код. Поэтому оставлять код без изменений предпочтительнее.

## Смысл оптимизации

**Главная мысль:** Оптимизации не бесплатны. Каждая оптимизация добавляет сложность и требует ресурсов. Важно оценивать, приносит ли она реальную пользу.

- **Память и производительность:** Мемоизация использует дополнительную память для хранения результатов и отслеживания зависимостей.
- **Сложность кода:** Избыточное использование оптимизаций усложняет код и делает его менее читаемым.
- **Необходимость измерения:** Оптимизируйте только после того, как убедитесь в наличии проблемы, используя инструменты профилирования.
- **Массив зависимостей и устаревшие замыкания:** Неправильное указание зависимостей может привести к багам из-за использования устаревших данных. Всегда следите за тем, чтобы массив зависимостей был актуален.

## Заключение

**Оптимизируйте осознанно.**

- **Не оптимизируйте преждевременно:** Сначала убедитесь, что есть проблема.
- **Используйте инструменты профилирования:** Они помогут выявить реальные узкие места.
- **Понимайте стоимость оптимизации:** Каждая оптимизация имеет свою цену в виде сложности кода и использования ресурсов.
- **Следите за развитием React:** В 19 версии React разработчики показали нам компайлер, который сам, под капотом занимается большей частью оптимизации

**Помните:** Главная цель — писать чистый, понятный и эффективный код. Оптимизации должны служить этой цели, а не препятствовать ей.
