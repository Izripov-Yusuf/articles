# Конспект: Типизация в TypeScript

Представьте, что вы работаете над крупным веб приложением на JavaScript. Команда постоянно использует объекты с данными пользователей, и однажды происходит классический сбой: один разработчик ожидает свойство userName и написал код под него, а другой по ошибке передаёт объект с полем username. Из-за такой казалось бы мелкой опечатки приложение падает или ведёт себя некорректно на продакшене. Подобных ошибок можно избежать, если заранее определить структуру данных и типы. Здесь и приходит на помощь TypeScript. В реальных коммерческих проектах статическая типизация TypeScript позволяет ловить подобные баги ещё на этапе разработки. Многие крупные компании используют TypeScript, чтобы код был более надёжным и понятным другим разработчикам.

**Зачем это нужно прямо сейчас:** Освоив типизацию в TypeScript, вы сможете писать более безопасный код. Вы сразу почувствуете пользу: среда разработки начнёт подсвечивать ошибки, когда вы опечатаетесь в названии свойства или передадите функции не тот тип данных. Вам станет легче работать в команде, чёткие интерфейсы и типы служат документацией к коду. Освоение утилитарных типов, таких как Partial или Pick, избавит от рутины дублирования типов и ускорит вашу работу.

**Тебе нужно изучить:**

```
Как определять интерфейсы (interface) для описания структуры объектов.
Как создавать псевдонимы типов с помощью type (алиасы типов) для именования
любых типов.
Что такое объединения типов (union types) и как с их помощью описывать переменные,
которые могут принимать несколько вариантов типов.
Как работать с утилитарными типами (Partial, Pick, Omit, Exclude, Extract и
др.) для гибкой трансформации уже определённых типов.
Зачем нужны обобщённые типы (generics) и как они используются вместе с
утилитарными типами для создания универсальных решений.
```
## Интерфейсы

Начнём с ситуации, когда вы описываете структуру сложного объекта. Допустим, в нашем приложении нужно работать с задачами (tasks) в таск трекере. Каждая задача имеет несколько свойств: идентификатор, название, описание, статус и т.д. Без чёткой типизации легко допустить ошибку, например передать функции объект задачи с пропущенным свойством. Интерфейсы TypeScript решают эту проблему, задавая контракт для объектов.

```
Интерфейс (англ. interface ) — это описание структуры объекта, определяющее
набор свойств и их типы.
```

Иными словами, интерфейс задаёт, какие поля должны (или могут) быть у объекта и какого они типа. Если какой-то обязательный ключ отсутствует или тип значения неверный, TypeScript выдаст ошибку ещё до запуска кода. Интерфейсы помогают делать код самодокументируемым и предотвратить множество ошибок, связанных с неправильным обращением к свойствам.

### Принципы интерфейсов


#### • Структурность.
TypeScript использует структурную типизацию: объект считается соответствующим интерфейсу, если у него есть требуемые свойства правильных типов. Не важно, как объект создан, важно, что у него есть нужная структура.

#### • Опциональные свойства.
В интерфейсе можно пометить некоторые поля как необязательные с помощью ?. Это удобно, когда, например, не у каждой задачи есть дедлайн: deadline?: string.

#### • Readonly свойства.
Интерфейс может объявлять свойства только для чтения с помощью ключевого слова readonly, предотвращая их изменение после создания объекта.

#### • Наследование.
Интерфейсы могут расширять друг друга (extends), позволяя строить иерархии типов. Это помогает избегать дублирования, когда несколько объектов имеют общие поля.


**Пример.** Опишем интерфейс Task для задачи и функцию, которая выводит информацию о задаче. Покажем, как интерфейс контролирует структуру объектов:

```typescript
interface Task {
  id: number; // уникальный идентификатор задачи
  title: string; // заголовок задачи
  description: string; // подробное описание
  status: string; // статус задачи (например, "todo" или "done")
  priority?: number; // приоритет задачи (необязательное свойство)
}

function printTask(task: Task) {
  // Функция ожидает объект, соответствующий интерфейсу Task
  console.log(`Task #${task.id}: ${task.title}`);
  console.log(`Status: ${task.status}`);
  if (task.priority !== undefined) {
    console.log(`Priority: ${task.priority}`);
  }
}

// Пример использования:
const myTask: Task = {
  id: 101,
  title: "Написать конспект",
  description: "Подготовить учебный материал по TypeScript",
  status: "in progress"
};

printTask(myTask);
```


В этом коде интерфейс Task задаёт контракт: у каждой задачи должны быть id, title, description и status. Свойство priority помечено как опциональное (?), поэтому объект задачи может его не иметь. Функция printTask объявлена так, что она принимает параметр типа Task. Это значит, что при попытке вызвать printTask с объектом, у которого, скажем, нет title или id (либо типы полей неправильные), код просто не скомпилируется. Например, если попробовать передать объект { id: 5, title: "Test" }, TypeScript выдаст ошибку: отсутствуют свойства description и status. Таким образом, интерфейсы сразу предупреждают разработчика об ошибках в структуре данных. Примечание: Интерфейсы в TypeScript не компилируются в JavaScript-код, они существуют только во время разработки для проверки типов.

Переходим к следующему концепту. Мы научились описывать структуры объектов с помощью интерфейсов. Но интерфейсы не единственный способ задавать типы в TypeScript. Часто требуется дать понятное имя не объекту, а к примеру комбинации примитивных типов или сигнатуре функции. Тут нам помогут псевдонимы типов.

## Алиасы типов

Представьте, что в нашем приложении задачи могут иметь автора, и каждому автору соответствует уникальный идентификатор. Пусть пока идентификаторы это простые числа. Мы могли бы везде использовать тип number, но это не говорит явно, что число является именно ID пользователя. Было бы удобно создать отдельный тип UserID для большей ясности. Кроме того, бывают сложные составные типы, которые хочется назвать одним словом. Алиасы типов (type aliases) позволяют дать удобные имена таким типам в коде.

```
Алиас типа (англ. type alias ) — это новое имя для существующего типа. С помощью
оператора type можно присвоить понятный ярлык любому типу: примитиву,
объекту, объединению других типов, функции и т.д.
```
Проще говоря, псевдоним типа не создаёт новый тип данных, а вводит альтернативное имя для уже определённого типа. Это помогает сократить длинные определения и сделать код читабельнее.

**Пример.** Давайте создадим несколько алиасов: один для примитивного типа ID, и один для описания функции. Например, определим тип идентификатора пользователя и тип функции логгера, которая выводит сообщения:

```typescript
type UserID = number; // Теперь UserID можно использовать вместо number для айди

type Logger = (message: string) => void; // Псевдоним для типа функции логгеров

// Используем наши новые типы:
const currentUserId: UserID = 42;
const consoleLogger: Logger = (msg: string) => {
  console.log(`LOG: ${msg}`);
};

consoleLogger(`Пользователь ${currentUserId} создан`);

// Также можно задавать алиасы для объектов или объединений:
type Point = { x: number; y: number }; // псевдоним типа объекта
type ID = string | number; // псевдоним для объединения типов
```
В этом примере UserID это алиас для типа number. Для компилятора UserID и number эквивалентны, но для нас такой код понятнее, сразу видно, где ожидается именно идентификатор пользователя. Аналогично, Logger задаёт тип "функция, принимающая строку и ничего не возвращающая". Мы присвоили consoleLogger функцию с соответствующей сигнатурой. TypeScript проверяет, что типы совпадают, если бы мы попытались присвоить consoleLogger функцию с неподходящей сигнатурой (например, принимающую число или возвращающую значение), он бы выдал ошибку.

Стоит отметить, что во многих случаях type и interface взаимозаменяемы, когда речь об описании объектов. Мы могли описать Point через интерфейс или Order (заказ) через type, результат был похожий. Однако есть отличия: интерфейсы поддерживают наследование и декларативное слияние, а type позволяет создавать алиасы для любых типов, включая объединения или кортежи, где интерфейс бессилен. Например, нельзя объявить "интерфейс, являющийся union типом", для этого нужен type. Важно понимать, когда лучше использовать каждый из подходов, но зачастую выбор это вопрос стиля и удобства.

```
Примечание. Если требуется объединить возможности, можно комбинировать
интерфейсы и алиасы. Например, интерфейс описывает объект, а алиас объединяет
этот интерфейс с другими типами. Главное избегать дублирования: определяйте
типы один раз, а переиспользуйте везде по имени.
```
Теперь, когда мы умеем задавать и именовать собственные типы, пора рассмотреть ещё один мощный инструмент TypeScript — объединение типов. Он пригодится, когда значение может быть нескольких разных форм.

## Объединение типов (Union)

Иногда свойства или переменные могут принимать разные формы. Например, уникальный идентификатор задачи может быть числом или строкой (в некоторых системах ID бывают числовые или в формате GUID строки). Или статус задачи: пусть сейчас это строка, но лучше ограничить набор допустимых значений конкретными литералами (например, 'todo' | 'in progress' | 'done' | 'archived'). В JavaScript мы просто договорились бы соблюдать условность, но TypeScript позволяет явно указать: значение может быть одного из нескольких типов. Объединённые типы позволяют задать альтернативы типов в рамках одного переменной.

```
Объединение типов (англ. union type ) — это тип, значения которого могут
относиться к одному из нескольких указанных типов. Объединения записываются
через вертикальную черту | между вариантами.
```

Проще говоря, union тип говорит: "Это может быть или то, или другое". Если переменная объявлена как string | number, ей можно присвоить либо строку, либо число (но ничего кроме этого). Попытка присвоить, например, boolean приведёт к ошибке компиляции. Объединения позволяют точно перечислить разрешённые варианты и отсекают все остальные.

**Пример.** Добавим к нашей модели задач более строгое определение статуса с помощью литеральных типов в объединении. Также создадим псевдоним типа ID, который может быть либо числом, либо строкой, и напишем функцию, принимающую такой ID:

```typescript
// Определим литеральный тип для статусов задач:
type Status = "todo" | "in progress" | "done" | "archived";

// Используем Status в интерфейсе Task вместо обычной строки:
interface Task {
  id: number;
  title: string;
  description: string;
  status: Status; // статус теперь ограничен четким набором значений
  priority?: number;
}

// Псевдоним ID как union:
type ID = number | string;

function findTaskById(taskId: ID, tasks: Task[]): Task | undefined {
  // Функция ищет задачу по ID, которое может быть числом или строкой
  return tasks.find(t => t.id === taskId);
}

// Пример использования:
const tasks: Task[] = [
  { id: 1, title: "Task1", description: "", status: "todo" },
  { id: 2, title: "Task2", description: "", status: "done" }
];

let result = findTaskById(1, tasks);
result = findTaskById("2", tasks); // можно искать строковым ID тоже
```
В этом коде мы определили type Status как объединение четырёх строковых литералов. Теперь свойство status в Task строго ограничено: ему можно присвоить только "todo", "in progress", "done" или "archived". Если попытаться присвоить task.status = "complete" (значение, не указанное в объединении), TypeScript выдаст ошибку. Аналогично, type ID = number | string означает, что идентификатор может быть либо числом, либо строкой. Функция findTaskById объявлена так, что taskId имеет тип ID. Это удобно: мы можем вызывать её и с числом, и со строкой. Если же передать, например, объект или null, компилятор не позволит этого сделать.

При использовании union типов важно учитывать, что внутри функции может потребоваться определить, какой именно вариант пришёл. В примере выше мы сравниваем t.id === taskId. TypeScript сам разберётся, как сравнить число со строкой или число с числом, но в более сложных случаях понадобятся механизмы сужения типа (type narrowing), такие как проверки с typeof или дискриминирующие поля. Это тема для отдельного занятия, но знайте, объединения часто идут рука об руку с проверками типов в runtime.

Мы разобрали основы объявления собственных типов. Теперь перейдём к следующей группе концептов — утилитарные типы. Предположим, наша модель Task включает десяток полей, и нам нужно создать на её основе вариации: скажем, тип для создания новой задачи (без id), или тип для обновления задачи (где все поля необязательны, потому что можно менять только часть). Вместо того чтобы вручную описывать такие варианты, мы можем использовать готовые инструменты, утилитарные типы TypeScript.

## Утилитарный тип Partial (опциональные свойства)

Продолжаем работу над задачами. Допустим, у нас есть функция для обновления задачи: она принимает объект задачи и объект с полями, которые нужно изменить. В JavaScript мы могли бы просто передавать объект с некоторыми полями, а остальные не указывать. Но TypeScript по умолчанию требует, чтобы объект соответствовал интерфейсу Task полностью, все обязательные свойства должны присутствовать. Как разрешить указать только те поля, которые хотим обновить? На помощь приходит утилитарный тип Partial. Он позволяет сделать поля объекта опциональными для обновления, не создавая вручную новый интерфейс.

```
Partial — утилитарный тип, который принимает тип T и создаёт новый тип, в
котором все свойства T помечены как необязательные. Другими словами,
Partial<T> описывает объект, содержащий подмножество свойств T.
```
Утилитарные типы это встроенные дженерик-шаблоны для трансформации типов. Partial один из самых простых и полезных: он позволяет, например, на основе полного типа задачи сделать тип "обновление задачи", где можно указывать только изменяемые поля.

**Пример.** Напишем функцию updateTask, которая принимает задачу и объект обновлений, и возвращает новую задачу с применёнными изменениями. Используем Partial<Task> для типа объекта обновлений:

```typescript
function updateTask(task: Task, updates: Partial<Task>): Task {
  // Объединим исходную задачу с обновлениями:
  const updated = { ...task, ...updates };
  return updated;
}

// Пример использования:
const initialTask: Task = {
  id: 5,
  title: "Написать тесты",
  description: "Добавить unit-тесты к модулю",
  status: "in progress",
  priority: 1
};

// Обновим статус и описание, остальные поля трогать не будем
const modified = updateTask(initialTask, {
  description: "Добавить unit-тесты к компоненту UI",
  status: "done"
});
```
Функция updateTask принимает параметр updates типа Partial<Task>. Это значит, что
updates может содержать только часть свойств из Task. В примере мы передали объект с
description и status — этого достаточно. Благодаря Partial компилятор не требует
указывать id , title и другие поля, они стали необязательными. При этом, если в объекте
обновлений опечататься в названии поля (например, написать statsu вместо status),
TypeScript это сразу поймает: ведь допустимы только свойства, существующие в Task.
Фактически, Partial<Task> автоматически сгенерировал для нас интерфейс вида:

```
{ id?: number; title?: string; description?: string; status?: Status;
priority?: number }
```
Каждое свойство стало опциональным. Мы успешно обновляем только заданные поля. Кстати,
обратите внимание: updateTask возвращает новый объект задачи, объединяя поля через
оператор расширения ```...``` . Так мы не мутируем исходный объект. Хотя это больше относится к
логике работы, TypeScript позволяет указать, что функция возвращает Task, то есть новую
задачу, полностью соответствующую интерфейсу (после объединения всех полей).

```
Примечание. Существует и утилита, обратная Partial, – Required. Она делает все
свойства обязательными. Например, Required<Task> потребует указать даже те
поля, что были опциональными. В нашем случае Required<Task> заставил бы
всегда указывать priority. Required пригодится реже, но о его наличии стоит
знать.
```
Мы только что сэкономили время, используя Partial вместо написания нового интерфейса
для обновлений. Дальше станет ещё лучше: рассмотрим утилиты для выбора и исключения
конкретных свойств.

## Утилитарные типы Pick и Omit (выбор свойств)

Предположим, нам нужно вывести на экран список задач с краткой информацией: только ID,
заголовок и статус, без всего остального. Можно создать новый интерфейс TaskPreview с
этими тремя полями. Но потом мы понимаем, что TaskPreview по сути дублирует часть Task.
Если в Task что-то поменяется (например, мы решим хранить статус как число), придётся не
забыть обновить и TaskPreview. Есть риск рассинхрона. Аналогично, для создания новой
задачи на сервер мы хотим тип, содержащий всё из Task, кроме поля id (ведь до сохранения
в базе у новой задачи нет идентификатора). Чтобы не дублировать код, используем утилитарные
типы Pick и Omit, которые позволяют на лету формировать новые типы из старых, выбирая или
исключая свойства.

```
Pick берет исходный тип T и выбирает из него указанный набор свойств, образуя новый
тип.

Omit берет исходный тип T и исключает из него перечисленные свойства, образуя
новый тип.
```

Оба эти утилитарных типа также являются _дженериками_ (обобщёнными): вы передаёте им
исходный тип и набор ключей, и на выходе получаете соответствующий подтип.

**Пример.** Создадим на основе Task два новых типа: 1. TaskPreview – содержит только id ,
title и status (выборка полей через Pick). 2. NewTask – содержит всё, что у Task,
кроме поля id (исключение через Omit).

И посмотрим, как их можно использовать:

```typescript
type TaskPreview = Pick<Task, "id" | "title" | "status">;
type NewTask = Omit<Task, "id">;

// Пример: список задач для превью (только с нужными полями)
const taskList: TaskPreview[] = [
  { id: 1, title: "Task1", status: "todo" },
  { id: 2, title: "Task2", status: "done" }
];

// Пример: создание новой задачи
function createTask(data: NewTask): Task {
  // на вход принимаем объект без id, присваиваем новый id и возвращаем полную Task
  const newId = Math.floor(Math.random() * 1000);
  return { id: newId, ...data };
}

const draft: NewTask = {
  title: "Написать документацию",
  description: "Создать README для проекта",
  status: "todo",
  priority: 2
};

const savedTask = createTask(draft);
console.log(savedTask.id); // у сохранённой задачи появился id
```
В коде мы определили TaskPreview через Pick<Task, "id" | "title" | "status">.
Второй параметр Pick, это объединение литеральных типов ключей, которые мы хотим взять.
В результате TaskPreview эквивалентен типу { id: number; title: string; status:
Status }. Если вдруг в Task изменить тип поля title или status, TaskPreview
автоматически подхватит эти изменения (потому что он ссылается на оригинал). Аналогично,
NewTask это Omit<Task, "id">. Мы “отрезали” свойство id , получив тип с остальными
свойствами задачи. Функция createTask демонстрирует применение: на вход она принимает
данные для новой задачи без id и возвращает полноценную Task, добавляя недостающий
идентификатор.


Таким образом, **Pick и Omit позволяют не дублировать определения типов**. Они особенно
полезны в больших проектах, где, к примеру, один и тот же объект может представляться по-
разному в разных контекстах (полная версия, превью, для редактирования и т.д.). Если завтра мы
добавим новое поле в Task, утилиты гарантируют, что все производные типы (Preview, NewTask
и др.) обновятся соответственно или, по крайней мере, TypeScript подскажет, где нужно внести
изменения.

```
Примечание. Схожие утилиты: Readonly (делает поля доступными только для
чтения) и Required (мы упоминали ранее, делает поля обязательными). Ещё есть
Record – для создания типа объекта с заданными ключами одного типа и
значениями другого. Все они работают по схожему принципу: берут исходный тип и
производят новый тип по определённым правилам.
```
Теперь мы умеем выделять подмножества свойств или убирать лишнее. Последний важный
случай – когда нужно работать не с свойствами объектов, а с **вариантами объединённого типа**.
Для этого существуют утилиты Exclude и Extract.

## Утилитарные типы Exclude и Extract (фильтрация объединений)

Помните, мы ввели тип Status для статусов задач. Допустим, в приложении есть фильтр,
который показывает только _активные_ задачи. Под активными мы подразумеваем все статусы,
кроме "archived". Мы могли бы вручную определить тип ActiveStatus = "todo" | "in
progress" | "done", но тогда нужно поддерживать его вручную в синхронизации с Status.
Вместо этого можно **исключить** из Status ненужный вариант. Аналогично, иногда требуется
извлечь пересечение двух объединений. Например, у нас может быть список ролей
пользователей, и мы хотим получить тип “общие роли” между двумя списками. Решение —
утилиты Exclude и Extract.

```
Exclude<UnionType, ExcludedMembers> — берёт объединение UnionType и исключает
из него все варианты, которые назначимы (assignable) к типу ExcludedMembers.
Extract<Type, Union> — берёт тип Type (часто тоже объединение) и извлекает из него
только те варианты, которые также присутствуют в объединении Union.
```
Проще говоря, Exclude = “удалить из объединения лишнее”, а Extract = “выбрать из
объединения общее с другим”.

**Пример.** Возьмём наш Status и определим на его основе: 1. ActiveStatus – все статусы
кроме "archived". 2. ArchivedStatus – пересечение Status с множеством {"archived",
"deleted"} (в данном случае ожидаем только "archived", так как "deleted" не входит в
Status).

Также рассмотрим пример с ролями пользователей для разнообразия:

```typescript
type ActiveStatus = Exclude<Status, "archived">;
// ActiveStatus эквивалентен "todo" | "in progress" | "done"

type ArchivedStatus = Extract<Status, "archived" | "deleted">;
// ArchivedStatus эквивалентен "archived" (только пересечение)

type UserRole = "admin" | "user" | "guest";
type CommonRoles = Extract<UserRole, "admin" | "moderator">;
// CommonRoles будет "admin" (общий элемент)
type NonGuests = Exclude<UserRole, "guest">;
// NonGuests будет "admin" | "user"
```
В коде ActiveStatus получен как Exclude<Status, "archived">. TypeScript берёт
объединение Status ("todo" | "in progress" | "done" | "archived") и вычитает из
него подтип "archived". Результат — объединение из оставшихся трёх строк. Если завтра в
Status добавится новый вариант (например, "paused"), ActiveStatus автоматически его
включит, ведь мы исключаем только "archived". С Extract аналогично: Extract<Status,
"archived" | "deleted"> вернёт только те варианты, которые есть и в Status, и в
"archived" | "deleted". Поскольку Status не знает про "deleted", общим окажется
только "archived". На примере UserRole видим, что Extract и Exclude работают со
словами так же, как и с литералами: CommonRoles — только "admin" (так как "moderator"
отсутствует в UserRole), а NonGuests — все роли кроме "guest".

Утилиты Exclude и Extract полезны при проектировании сложных типов, особенно в
библиотеках или фреймворках, где есть конфигурации с множеством вариантов. Они помогают
строить новые типы на основе существующих, не перечисляя вручную все случаи. Например,
вы можете иметь объединение возможных событий и получить подмножество событий,
связанных с пользователем, через Extract. Или отфильтровать из объединения типов все
функции, оставив только простые значения, через Exclude<Union, Function>.

Теперь мы познакомились со всеми запланированными частными концептами недели:
интерфейсы, алиасы, объединения и ключевые утилитарные типы. Давайте посмотрим на общие
черты этих возможностей.

## Обобщение

Во всех рассмотренных случаях прослеживаются несколько общих идей. Во-первых, TypeScript позволяет **описать структуру данных и возможные варианты** _до_ выполнения программы. Мы
задавали контракты (через интерфейсы), именовали комбинации типов (через type-алиасы),
перечисляли допустимые альтернативы (через union). Это всё проявления статической
типизации — стремления выявить проблемы на этапе компиляции.

Во-вторых, мы увидели принцип переиспользования типов. Вместо того чтобы повторять
описание похожих сущностей, мы брали уже существующий тип (например, Task) и на его
основе строили новые (Partial<Task>, Pick<Task, ...> и т.д.). Это экономит время и
устраняет целый класс ошибок, связанных с расхождением в определениях. TypeScript
предоставляет богатый набор инструментов для трансформации типов: мы рассмотрели лишь
ключевые из них, но их объединяет то, что все они работают _на уровне типов_ , не влияя
непосредственно на выполнение кода.

Наконец, все эти концепты основаны на идее обобщённости (generic). Интерфейсы и типы могут
быть _обобщёнными_ (например, interface Box<T> { value: T }), утилиты Partial, Pick, Exclude
и прочие сами являются дженериками, которые принимают параметры-типы. За счёт этого
типизация в TS очень гибкая: мы описываем не конкретные значения, а целые пласты


возможных форм данных. Например, Partial<T> подходит для любого типа T — это шаблон,
как функция для типов.

Обобщая всё вышесказанное, можно сформулировать основной концепт недели.

## Типизация в TypeScript

```
Статическая типизация (англ. static typing ) — это механизм языка, позволяющий
задавать строгие типы данных для переменных, параметров и объектов во время
разработки, чтобы обнаруживать ошибки до запуска программы. В TypeScript
система типизации включает разнообразные инструменты (интерфейсы, алиасы,
объединения, утилитарные и обобщённые типы), которые работают совместно,
помогая разработчику писать более надёжный и выразительный код.
```
### Принципы статической типизации в TypeScript

```
Проверка на этапе компиляции. Код проверяется компилятором: несоответствие типов
приводит к ошибке сборки. Это значит, множество багов (опечатки, неправильные типы)
ловятся заранее.
Структурная типизация. Совместимость типов определяется по их структуре (набору
свойств и их типам), а не по именам. Это упрощает интеграцию различных частей кода —
важна форма данных, а не происхождение.
Обобщённость и модульность. Система типов позволяет определять шаблоны (generics),
чтобы описывать семейства типов. Утилитарные типы — пример таких шаблонов,
встроенных в язык.
Отсутствие влияния на runtime. Все типы "стираются" при компиляции в JavaScript. Они
существуют только пока вы пишете код, но не замедляют работу приложения. Поэтому
типы — как дополнительные "настройки" для разработчика и инструментария, не
добавляя накладных расходов при исполнении.
```
```
Примечание. Несмотря на строгую типизацию, TypeScript остаётся надстройкой
над JavaScript. Вы всегда можете постепенно мигрировать код: в крайнем случае тип
any или операторы приведения типов позволят вам интегрировать небезупречно
типизированный код. Однако злоупотреблять такими лазейками не стоит —
теряется смысл безопасности типов.
```
Теперь, когда все части мозаики сложились, давайте взглянем на небольшой итоговый пример,
объединяющий разные аспекты. Представим, что мы реализуем логику создания и обновления
задач, используя все наши определения:

**Пример.** Финальный кейс: создание новой задачи, обновление её статуса и получение превью списка активных задач.

```typescript
// Используем уже определенные ранее интерфейсы и типы:
const tasks: Task[] = [];

// Создаём новую задачу (NewTask не содержит id, функция сама присвоит id)
const newTaskData: NewTask = {
  title: "Подготовить демо",
  description: "Создать демонстрацию для презентации",
  status: "todo",
  priority: 3
};
const createdTask: Task = createTask(newTaskData);
tasks.push(createdTask);

// Обновляем задачу: меняем статус на "done"
const updatedTask: Task = updateTask(createdTask, { status: "done" });
tasks[0] = updatedTask; // заменяем в списке

// Фильтруем активные задачи (исключаем архивированные)
const activeTasks: Task[] = tasks.filter(t => t.status !== "archived");

// Формируем список превью для интерфейса пользователя
const taskPreviews: TaskPreview[] = activeTasks.map(t => ({
  id: t.id,
  title: t.title,
  status: t.status
}));

console.log(taskPreviews);
```
В этом примере мы используем несколько ранее объявленных типов: - NewTask (на основе
Omit<Task, "id">) для создания задачи без идентификатора. - Функцию createTask,
которая добавляет ID и возвращает полноценный Task. - Функцию updateTask с
Partial<Task> для изменения статуса. - Операцию фильтрации списка, используя знание о
Status: исключаем архивные задачи (фактически применение логики, аналогичной
Exclude<Status, "archived">). - Формирование массива TaskPreview с помощью map ,
выбирая только нужные поля для превью (эквивалент Pick<Task, "id" | "title" |
"status">).

TypeScript на каждом шаге проверяет, что мы не допустили ошибок: - При добавлении задачи
убеждается, что объект соответствует NewTask (все необходимые поля есть, лишних нет). - При
обновлении не даёт указать несуществующие поля в объекте обновлений. - При создании списка
превью контролирует соответствие структуры TaskPreview (например, не позволит забыть
включить id или использовать свойство, которого нет).

Как итог, статическая типизация TypeScript связала все части логики. Код получается более
уверенным: если он компилируется без ошибок, высока вероятность, что основные ошибки с
несоответствием данных устранены.

## Выводы

Интерфейс — это контракт на структуру объекта. Он задаёт, какие свойства и какого типа
должны быть у объекта, позволяя ловить ошибки несоответствия структуры на этапе
компиляции.

Алиас типа (оператор type) — позволяет давать понятное имя любому типу. Создание
псевдонимов упрощает работу со сложными типами и улучшает читабельность, не
создавая новых типов на этапе выполнения.

Объединение типов (union) — это тип, значения которого могут относиться к одному из
нескольких вариантов. Объединения позволяют явно ограничить переменную
несколькими допустимыми типами (например, только строка или число), предотвращая
передачу недопустимых значений.

Утилитарные типы облегчают работу с уже определёнными типами:
Partial делает все свойства типа опциональными (позволяя, например, передать в
функцию обновления только изменяемые поля).

Required — обратный Partial, делает все свойства обязательными.

Pick создаёт новый тип, содержащий только выбранные свойства из исходного типа.

Omit создаёт тип, исключающий перечисленные свойства исходного типа.

Exclude удаляет из объединения все члены, которые соответствуют указанному типу.

Extract извлекает из типа только те части, которые присваиваются другому (пересечение объединений).

Generics (обобщённые типы) — ключевой механизм, используемый во многих
утилитарных типах. Они позволяют параметризовать типы (например, Partial<T> для
любого типа T ) и создавать гибкие, повторно используемые определения типов.

Все эти инструменты работают во время разработки и компиляции. В итоге система
типов TypeScript делает код надёжнее, одновременно служа живой документацией и не
влияя на производительность приложения.

```
## Ссылки на полезные источники:

```
Документация: TypeScript Handbook – Utility Types (описание встроенных утилитарных
типов вроде Partial, Pick, Omit и др.).
Статья: Искусство типизации: TypeScript Utility Types – обзор утилитарных типов TypeScript с
простыми примерами на русском языке.
Статья: Интерфейсы и типы TypeScript: в чём разница – разбор отличий между interface
и type (алиасом типа), с рекомендациями по выбору.
```



# Практические задачи

## Задача 1. Фильтр чисел по диапазону

**Сценарий:** Вы разрабатываете модуль анализа данных. В нём часто нужно **отбирать числа в
заданном диапазоне**. Вместо того чтобы каждый раз писать однотипный код фильтрации, вы
решили вынести эту логику в отдельную функцию. Требуется, чтобы решение было типизировано
с помощью TypeScript — это поможет избежать ошибок, если кто-то попытается использовать
функцию неправильно.

**Входные данные:** Функция должна принимать два аргумента: 1. Объект диапазона с двумя
числовыми свойствами: нижняя граница min и верхняя граница max. 2. Массив чисел, которые
нужно отфильтровать.

**Логика работы кода:** Функция проверяет каждый элемент массива и выбирает только те числа,
которые находятся **между min и max включительно**. То есть число x проходит фильтр, если
min <= x <= max. Остальные числа отбрасываются.



**Выходные данные:** Функция возвращает **новый массив** чисел, содержащий только значения из
исходного массива, попадающие в заданный диапазон. Порядок чисел сохраняется. Например,
для диапазона { min: 10, max: 20 } и массива [5, 15, 25] результатом будет массив
[15], так как только 15 лежит между 10 и 20.

**Требования к решению:** - Опишите **интерфейс** для объекта диапазона, чтобы у него
гарантированно были свойства min и max типа number. - Функция должна быть объявлена с
явными типами параметров и возвращаемого значения. Используйте созданный интерфейс для
типизации параметра-диапазона. - Учтите, что диапазон задаётся включительно: числа равные
min или max тоже должны отбираться. - Функция **не должна** изменять исходный массив.
Формируйте новый массив результатов. - Добавьте несколько тестовых вызовов функции с
выводом результатов, чтобы показать правильность работы (например, через console.log).

**Вопросы для размышления:** - Как интерфейс поможет избежать ошибок при вызове функции? -
Что произойдёт, если перепутать местами min и max при вызове? Нужно ли это обрабатывать?

- Почему важно явно указать, что функция возвращает массив чисел, даже если TypeScript может
вывести этот тип?

**Решение.** Давайте реализуем интерфейс диапазона и функцию фильтрации по диапазону:

```typescript
interface Range {
  min: number;
  max: number;
}

function filterRange(range: Range, numbers: number[]): number[] {
  const result: number[] = [];
  for (const num of numbers) {
    // Проверяем попадание числа в диапазон [min, max]
    if (num >= range.min && num <= range.max) {
      result.push(num);
    }
  }
  return result;
}

// Тестовые примеры:
const range1: Range = { min: 1, max: 5 };
const nums1 = [0, 1, 2, 5, 6];
console.log(filterRange(range1, nums1)); // Ожидается: [1, 2, 5]

const range2: Range = { min: 10, max: 8 };
const nums2 = [8, 9, 10];
console.log(filterRange(range2, nums2)); // Ожидается: [] (min > max, диапазон пуст)
```
**Пояснение:** Мы объявили интерфейс Range с двумя полями min и max. Функция
filterRange принимает range: Range и массив чисел. Внутри она проверяет каждый
элемент массива: оператор >= и <= гарантирует, что числа равные границам тоже включаются. Результаты собираются в новый массив result. Таким образом, исходный массив numbers не меняется (мы соблюли иммутабельность).

TypeScript здесь выполняет несколько ролей: - **Контроль входных данных:** благодаря
интерфейсу Range, нельзя случайно передать в filterRange объект с неправильными
именами свойств или пропустить одно из них. Попытка вызвать, например,
filterRange({ start: 1, end: 5 }, [1,2,3]) приведёт к ошибке на этапе компиляции
(“Property 'min' is missing...”). - **Подсказка разработчику:** когда кто-то использует эту функцию в
будущем, IDE будет подсказывать, что нужно передать объект с min и max. Это делает код
понятнее. - **Возвращаемое значение:** функция явно объявлена как возвращающая number[].
Хотя компилятор сам мог бы вывести тип, явное указание служит документацией. Если мы
изменим реализацию, TS проследит, чтобы возвращался массив чисел. В нашем случае, result
типизируется как number[] автоматически, так что всё корректно.

Отдельно отметим: если min > max (как во втором тесте { min: 10, max: 8 }), наша
функция просто вернёт пустой массив, потому что ни одно число не удовлетворит условие num
>= 10 && num <= 8. В реальных сценариях можно добавить проверку и выбросить ошибку или
поменять границы местами. Но с точки зрения типизации, ситуация “перепутанные границы” не
нарушает работу TypeScript — это логическая ошибка, а не типовая, поэтому мы решаем её по
усмотрению. В данном решении мы оставили как есть, пустой результат естественным образом
сигнализирует о неверном диапазоне.

## Задача 2. Выбор свойств объекта

**Сценарий:** Вы работаете над функционалом экспорта данных. Пользователь может выбрать,
какие поля объекта ему нужны на выходе. Например, из объекта пользователя (со свойствами
имя, возраст, email, адрес) можно выбрать только имя и email. Чтобы не писать отдельную
функцию под каждый набор полей, вы решили сделать одну универсальную функцию
**selectFields** , способную отбирать любые указанные свойства любого объекта. TypeScript
должен помочь сделать функцию безопасной: она должна работать только с полями, которые
действительно есть в объекте.

**Входные данные:** Функция selectFields принимает: 
1. **obj** – произвольный объект типа T.
2. **keys** – массив ключей (строк) типа K[] , которые надо вытащить из объекта. Здесь K
представляет собой **множество имен свойств** из объекта T.

Например, для объекта пользователя user с полями { name, age, email, address }
массив ключей может быть ["name", "email"].

**Логика работы кода:** Функция должна пройти по списку ключей и сформировать **новый объект** ,
содержащий только свойства obj с этими именами. Если в массиве ключей указано свойство,
которого в объекте нет, функция на этапе компиляции не должна вообще позволить такой вызов
(то есть список ключей должен быть _типобезопасным_ ). Порядок свойств в результирующем
объекте не важен (можно добавлять по мере обхода массива ключей).

**Выходные данные:** Возвращается новый объект, содержащий пары "ключ-значение" из
исходного объекта obj только для указанных ключей. Значения берутся из obj. Если массив
keys пуст, возвращается пустой объект. Если keys содержит, например, ["name",
"email"], то возвращаемый объект будет вида { name: obj.name, email: obj.email }.


**Требования к решению:** - Функция должна быть **обобщённой (generic)** , чтобы работать с
объектом любого типа. Используйте параметр типа <T> для объекта. - Тип массива ключей
должен быть связан с ключами объекта. Используйте второй параметр типа, например <K
extends keyof T>, чтобы ограничить допустимые значения элементов keys только
существующими свойствами T. - Для создания результирующего типа воспользуйтесь утилитой
Pick. Возвращаемый функцией тип должен быть Pick<T, K>, то есть объект, содержащий
свойства T с ключами K. - Внутри функции при сборке результирующего объекта можно
временно ослабить проверку типов (например, через приведение к any ), поскольку компилятор
не всегда способен вывести тип новой переменной в процессе заполнения. Главное — корректно
объявить тип возвращаемого значения, и соблюсти его на практике. - Протестируйте функцию на
разных объектах: убедитесь, что при попытке запросить несуществующий ключ происходит
ошибка компиляции.

**Вопросы для размышления:** - Почему мы делаем функцию обобщённой? Что будет, если указать
тип any для ключей? - Как extends keyof T помогает предотвратить ошибочные вызовы
функции? - Можно ли обойтись без утилитарного типа Pick при объявлении возвращаемого
типа? Какие есть альтернативы?

**Решение.** Реализуем функцию selectFields с использованием дженериков и утилиты Pick:

```typescript
function selectFields<T, K extends keyof T>(obj: T, keys: K[]): Pick<T, K> {
  const result: Partial<Pick<T, K>> = {}; // промежуточно используем Partial для сборки
  for (const key of keys) {
    // TS знает, что key является ключом T, поэтому obj[key] существует
    result[key] = obj[key];
  }
  return result as Pick<T, K>; // приводим результат к полному Pick<T, K>
}

// Пример 1: объект пользователя
interface User {
  name: string;
  age: number;
  email: string;
  address: string;
}

const user: User = {
  name: "Alice",
  age: 30,
  email: "alice@example.com",
  address: "Wonderland"
};

const userContact = selectFields(user, ["name", "email"]);
/* тип userContact выведется как Pick<User, "name" | "email">,
то есть { name: string; email: string } */
console.log(userContact); // { name: "Alice", email: "alice@example.com" }

// Пример 2: объект товара
const product = { id: 101, title: "Phone", price: 250, stock: 10 };

const brief = selectFields(product, ["title", "price"]);
/* brief имеет тип { title: string; price: number } */
console.log(brief); // { title: "Phone", price: 250 }

// Попытка указать несуществующее поле приводит к ошибке компиляции:
// selectFields(user, ["name", "salary"]); // Ошибка: тип '"salary"' не удовлетворяет ограничению 'keyof User'
```
**Пояснение:** Наша функция selectFields объявлена с двумя параметрами типа: <T, K
extends keyof T>. - T – тип объекта, передаваемого в функцию. - K extends keyof T – тип
ключей, ограниченный множеством свойств объекта T. Проще говоря, K может быть только
тем, что представляет реальный ключ в объекте T. Если T = User, то K может быть "name",
или "email", или объединением "name" | "email", и т.д., но **не может** быть строкой,
отсутствующей в User.

Аргумент obj имеет тип T , а аргумент keys – тип K[] (массив строк, каждая из которых
является допустимым ключом T ). Возвращаемый тип функции объявлен как Pick<T, K>. Это
значит: новый объект будет содержать только свойства из списка K оригинального типа T.

В реализации функции мы используем небольшую хитрость. Мы заводим переменную result с
типом Partial<Pick<T, K>>, то есть временно позволяем ей быть неполной версией
целевого типа. Это нужно потому, что мы будем поэтапно добавлять свойства в result. В цикле
for...of TypeScript знает, что каждая key принадлежит keyof T, поэтому obj[key]
допустимо. Мы присваиваем result[key] = obj[key]. Здесь возникает тонкость: переменная
result изначально пустая, и TS в строгом режиме может возражать против присвоения через
индекс без инициализации. Однако благодаря объявлению Partial, мы говорим компилятору
“все ок, мы заполним нужные поля”. После цикла мы приводим result к Pick<T, K> с
помощью as. Это утверждение типов безопасно, потому что: 1. Мы действительно прошлись по
всем ключам из keys и присвоили для каждого значение. 2. keys включает именно те ключи,
которые должны быть в конечном объекте (никаких лишних).

Если бы мы не сделали Partial, пришлось бы инициализировать result через приведение к
any или добавлять! (non-null assertion) при присвоении, что менее явно. Выбранный подход
делает код понятным и относительно типобезопасным внутри функции.

В примерах использования: - Для объекта user типа User вызов selectFields(user,
["name", "email"]) даёт тип Pick<User, "name" | "email">. TypeScript выводит это
автоматически: он видит, что T – User, а K – "name" | "email". Попытка указать
"salary" в массиве вызвала ошибку ещё до выполнения — компилятор сразу сообщил, что
такого ключа нет в User. Это заслуга ограничения K extends keyof T: без него (если бы K
был просто string), функция бы попыталась выполняться с недопустимым ключом и могла
вернуть объект с лишними или undefined значениями. - Для объекта product (у которого мы
не явно описывали интерфейс, но TypeScript вывел тип
{ id: number; title: string; price: number; stock: number }), вызов
selectFields(product, ["title", "price"]) вернёт объект типа { title: string;
price: number }. Здесь TypeScript тоже проверяет: "title" и "price" действительно
входят в keyof typeof product.


Мы сделали функцию обобщённой, чтобы она была **универсальной**. Если бы мы ограничились
конкретным интерфейсом или использовали типы вроде any , мы бы потеряли всю пользу.
Например, со вторым параметром как string[] (без связи с T ) функция бы позволяла
написать что угодно в массиве ключей, и мы получили бы undefined на несуществующих
полях уже во время выполнения. Благодаря дженерикам и keyof, наша функция
selectFields гарантирует: вы не попросите данных, которых нет, и вам не придётся
приводить результаты к нужному типу – он уже известен компилятору.


