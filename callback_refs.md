# Callback рефы в React: что это такое и с чем едят

### Введение

При разработке у нас зачастую возникает необходимость прямого взаимодействия с DOM-элементами. Для такого случая React предоставляет нам механизм рефов (refs), который позволяет получать доступ к элементам после того, как они зарендерятся. Чаще всего используются обычные объектные рефы через useRef (обзовём их так), но также существует другой подход — callback refs. Этот метод даёт нам дополнительную гибкость и контроль над жизненным циклом элементов, позволяя выполнять необходимые нам специфические действия в точные моменты привязки и отвязки элементов. В этой статье я хочу объяснить, что такое callback refs, как они работают, показать распространённые проблемы при их использовании и показать практические примеры их использования.

### Что такое callback refs?

callback refs — это по сути просто функция, которую мы передаём в атрибут ref элемента или компонента. В отличие от объектных рефов, React вызывает эту функцию дважды:

1. **При монтировании элемента:** функция вызывается с самим DOM-элементом или экземпляром компонента.
2. **При размонтировании элемента:** функция вызывается с null. (логично, ведь компонент или элемент размонтирован)

Этот механизм позволяет нам выполнять определённые действия именно в тот момент, когда элемент появляется или исчезает из DOM, что открывает для нас дополнительные возможности для управления жизненным циклом элемента.

### Простой пример callback ref

Рассмотрим базовый пример функционального компонента, который устанавливает фокус на инпут при его монтировании:

```tsx
import React from 'react';

function InputWithCallbackRef() {
  const handleRef = (element: HTMLInputElement | null) => {
    if (element) {
      element.focus();
      console.log('Инпут сфокусирован:', element);
    } else {
      console.log('Инпут размонтирован');
    }
  };

  return <input ref={handleRef} placeholder="Автоматический фокус" />;
}

export default InputWithCallbackRef;
```

В этом примере функция handleRef автоматически устанавливает фокус на инпут при его монтировании и выводит сообщение в консоль при размонтировании. (мы пока не делаем размонтирование, примеры с ним будут далее)

### Как работают callback refs

Callback refs дают более тонкий контроль над привязкой рефов по сравнению с объектными рефами. Рассмотрим, как они работают на деле:

1. **Монтирование:** Когда элемент монтируется в DOM, React вызывает функцию реф с самим DOM-элементом. Это позволяет вам выполнять действия с элементом сразу после его появления на странице.

2. **Размонтирование:** Когда элемент размонтируется, React вызывает функцию реф с null. Это даёт нам возможность очистить или отменить любые действия, связанные с элементом.

### Пример: отслеживание монтирования и размонтирования

```tsx
import React, { useCallback, useState } from 'react';

function MountUnmountTracker() {
  const [isVisible, setIsVisible] = useState(false);

  const handleRef = useCallback((node: HTMLDivElement | null) => {
    if (node) {
      console.log('Элемент монтирован:', node);
    } else {
      console.log('Элемент размонтирован');
    }
  }, []);

  return (
    <div>
      <button onClick={() => setIsVisible((prev) => !prev)}>
        {isVisible ? 'Скрыть' : 'Показать'} элемент
      </button>
      {isVisible && <div ref={handleRef}>Отслеживаемый элемент</div>}
    </div>
  );
}

export default MountUnmountTracker;
```

Каждый раз, когда мы переключаем видимость элемента, функция handleRef вызывается с соответствующим аргументом (node или null), позволяя отслеживать момент привязки и отвязки элемента.

## Частые проблемы и решения

### Проблема: повторные вызовы callback ref

Одна из частых проблем при использовании callback refs, это повторное создание функции рефа при каждом ре-рендере компонента. Из-за этого React вызывает callback ref сначала с null, а затем типа с новым элементом, даже если сам наш элемент или компонент никак не изменились. В результате у нас могут возникнуть нежелаемые побочные эффекты.

**Пример проблемы**
Рассмотрим компонент Basic, который содержит кнопку для переключения видимости div с callback ref и кнопку производящую форс апдейт компонента:

```tsx
import React, { useState, useReducer } from 'react';

function Basic() {
  const [showDiv, setShowDiv] = useState(false);
  const [, forceRerender] = useReducer((v) => v + 1, 0);

  const toggleDiv = () => setShowDiv((prev) => !prev);

  const refCallback = (node: HTMLDivElement | null) => {
    console.log('div', node);
  };

  return (
    <div>
      <button onClick={toggleDiv}>Toggle Div</button>
      <button onClick={forceRerender}>Rerender</button>
      {showDiv && <div ref={refCallback}>Пример div</div>}
    </div>
  );
}

export default Basic;
```

Каждый раз при нажатии на кнопку Rerender, компонент перерисовывается, создавая новую функцию refCallback. Это приводит к вызову refCallback(null) и затем refCallback(node), не смотря на то, что наш элемент с рефом по сути никак не изменился. В консоли будут появляться сообщения с div и null поочерёдно снова и снова, чего мы конечно не хотели бы.

**Решение: Мемоизация callback ref с помощью useCallback**
Избежать это довольно легко, используйте useCallback для мемоизации функции. Это гарантирует, что функция останется неизменной между ре-рендерами, если её зависимости не изменились.

```tsx
import React, { useState, useCallback, useReducer } from 'react';

function Basic() {
  const [showDiv, setShowDiv] = useState(false);
  const [, forceRerender] = useReducer((v) => v + 1, 0);

  const toggleDiv = () => setShowDiv((prev) => !prev);

  const refCallback = useCallback((node: HTMLDivElement | null) => {
    console.log('div', node);
  }, []);

  return (
    <div>
      <button onClick={toggleDiv}>Toggle Div</button>
      <button onClick={forceRerender}>Rerender</button>
      {showDiv && <div ref={refCallback}>Пример div</div>}
    </div>
  );
}

export default Basic;
```

Теперь функция refCallback создаётся только один раз, при первом рендере, и не будет вызываться лишний раз при последующих ре-рендерах. Это предотвратит не нужные вызовы и улучшит производительность компонента.

## Когда использовать callback refs вместо обычных

Хотя большинство задач с рефами можно решить с помощью объектных рефов через useRef, есть ситуации, когда callback refs предоставляют некоторые преимущества:

1. **Инициализация и очистка сторонних библиотек:** Когда нужнл точно определить момент инициализации сторонних библиотек или подписок, callback refs дают нам выполнять эти действия в момент привязки и отвязки элемента.

2. **Динамические списки элементов:** При работе с динамическими списками элементов, где количество элементов может меняться, callback refs облегчают управление множественными рефами.

3. **Управление жизненным циклом элементов:** Если потребуется выполнять специфические действия при монтировании или размонтировании элементов, callback refs предоставят такую возможность.

4. **Сложные взаимодействия с DOM:** В случаях, когда взаимодействие с DOM требует определённого порядка действий, callback refs могут быть более подходящей опцией.

## Новые возможности в React 19: Поддержка callback refs

С выходом React 19 были внесены улучшения в обработку наших callback refs, включая автоматическую очистку и оптимизацию вызовов функций рефов. Теперь React более эффективно управляет вызовами callback refs, уменьшая вероятность утечек памяти.

### Что добавлено в React 19

1. **Автоматическая очистка:** React теперь автоматически обрабатывает очистку callback refs при размонтировании элементов, что упрощает для нас задачу управления ресурсами.

2. **Оптимизация вызовов**: Улучшена производительность вызовов callback refs, особенно при частых ре-рендерах и динамических изменениях DOM.

3. **Лучшее взаимодействие с хуками эффекта:** callback refs теперь лучше взаимодействуют с хуками useEffect и useLayoutEffect, обеспечивая предсказуемый порядок выполнения.

## Порядок вызова callback refs, useLayoutEffect и useEffect

Важно понимать, как именно callback refs взаимодействуют с хуками useEffect и useLayoutEffect, чтобы правильно организовать логику инициализации и очистки ресурсов.

### Порядок вызова

1. **callback ref:** Вызывается сразу после рендеринга DOM-элементов, **до** выполнения хуков эффекта.
2. **useLayoutEffect:** Выполняется после всех изменений DOM, **но до отрисовки**.
3. **useEffect:** Выполняется после отрисовки.

```tsx
import React, { useEffect, useLayoutEffect, useCallback } from 'react';

function WhenCalled() {
  const refCallback = useCallback((node: HTMLDivElement | null) => {
    if (node) {
      console.log('Callback ref вызван для div:', node);
    } else {
      console.log('Callback ref отвязал div');
    }
  }, []);

  useLayoutEffect(() => {
    console.log('useLayoutEffect вызван');
  }, []);

  useEffect(() => {
    console.log('useEffect вызван');
  }, []);

  return (
    <div>
      <div ref={refCallback}>Элемент для отслеживания</div>
    </div>
  );
}

export default WhenCalled;
```

**Вывод в консоль:**

1. "Callback ref вызван для div: [div элемент]"
2. "useLayoutEffect вызван"
3. "useEffect вызван"

Этот порядок подтверждает, что callback refs вызываются до хуков эффекта, что нужно учитывать при написании кода.

## Сравнение обычных refs и callback Refs

### Обычные refs (useRef)

**Преимущества:**

- Простота использования.
- Покрывают большинство стандартных задач, таких как установка фокуса или сохранение значения между рендерами.
- Легко интегрируются с useLayoutEffect и useEffect.

**Недостатки:**

- Менее гибкие в управлении жизненным циклом элементов.
- Труднее управлять множественными рефами динамически.

## callback refs

**Преимущества:**

- Более гибкие и контролируемые.
- Позволяют выполнять действия в точные моменты привязки и отвязки элементов.
- Удобны для динамических списков и интеграции со сторонними библиотеками.

**Недостатки:**

- Требуют большей внимательности в реализации, особенно с точки зрения мемоизации функций.
- Могут приводить к дополнительным вызовам при неправильной реализации.

## Выбор между обычными refs и callback refs

- **Используйте обычные рефы** (useRef), когда вам нужен простой доступ к DOM-элементу или сохранение значения между рендерами без необходимости выполнять дополнительные действия при привязке или отвязке элемента.
- **Используйте callback refs**, когда требуется более тонкий контроль над жизненным циклом элемента, интеграция со сторонними библиотеками или управление множественными динамическими рефами.

## Заключение

Callback refs в React — это полезный инструмент, дающий разработчикам дополнительную гибкость и контроль над взаимодействием с DOM-элементами. Хотя в большинстве случаев стандартные объектные рефы через useRef полностью удовлетворяют наши с вами потребности, callback refs помогают в более сложных сценариях, которые мы обсудили выше
